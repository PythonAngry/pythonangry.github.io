<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pythonangry.github.io</id>
    <title>PythonAngry</title>
    <updated>2020-04-27T05:16:55.817Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pythonangry.github.io"/>
    <link rel="self" href="https://pythonangry.github.io/atom.xml"/>
    <logo>https://pythonangry.github.io/images/avatar.png</logo>
    <icon>https://pythonangry.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, PythonAngry</rights>
    <entry>
        <title type="html"><![CDATA[0425 | 图书馆培训]]></title>
        <id>https://pythonangry.github.io/post/FgB7Eg-7s/</id>
        <link href="https://pythonangry.github.io/post/FgB7Eg-7s/">
        </link>
        <updated>2020-04-25T09:24:41.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-中小学图书馆图书审查清理专项行动在线培训">一、中小学图书馆图书审查清理专项行动在线培训</h3>
<h4 id="11-培训观点摘录">1.1 培训观点摘录</h4>
<ul>
<li>图书馆教辅书籍存量较大，书籍质量差，副本存量大，含有非中小学生适读内容，书籍出版时期久远</li>
<li>图书馆馆员素质参差不齐，缺乏电脑、移动终端及其软件使用技能</li>
<li>培训演讲内容空洞，非常具有中国社会主义特色（除剔旧教学部分）</li>
</ul>
<h4 id="12-审查依据">1.2 审查依据</h4>
<ul>
<li>《关于加强新时期中小学图书建设与应用工作的意见》<br>
教基一 [2015] 2号 教育部 文化部 国家新闻出版广电总局</li>
<li>《关于印发《中小学图书馆（室）教程》的通知》<br>
教基 [2018] 5号</li>
<li>《关于开展全国中小学图书馆图书审查清理专项行动的通知》<br>
教基司函 [2019] 55号</li>
<li>《关于印发《2019年全国中小学图书馆（室）推荐书目》的通知》<br>
教基司函 [2019] 47号</li>
<li>书籍需具备【中央宣传部出版物数据中心】核发书号</li>
</ul>
<h4 id="13-审查工具">1.3 审查工具</h4>
<ul>
<li>中小学图书馆复选与剔旧程序
<ul>
<li>手机端（微信小程序）</li>
<li>电脑端（www.areader.com）</li>
</ul>
</li>
</ul>
<h4 id="14-审查流程">1.4 审查流程</h4>
<figure data-type="image" tabindex="1"><img src="https://pythonangry.github.io/post-images/1587807626607.png" alt="" loading="lazy"></figure>
<h3 id="二-中小学图书馆环境建设讲座">二、中小学图书馆环境建设讲座</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0422 | 数据结构与算法（2）]]></title>
        <id>https://pythonangry.github.io/post/X3rieogCq/</id>
        <link href="https://pythonangry.github.io/post/X3rieogCq/">
        </link>
        <updated>2020-04-22T02:23:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="5排序与查找">5.排序与查找</h3>
<h4 id="51顺序查找">5.1顺序查找</h4>
<p><strong>5.1.1 无序表顺序查找</strong> O(n)</p>
<pre><code>def sequentialSrarch(alist, item):
    pos = 0
    found = False

    while pos &lt; len(alist) and not found:
        if alist[pos] == item:
            found = True
        else:
            pos = pos + 1

    return found

testlist = [1,2,32,8,17,19,42,13,0]
print(sequentialSrarch(testlist, 3))
print(sequentialSrarch(testlist, 13))
</code></pre>
<p><strong>5.1.2 有序表顺序查找</strong> O(n)</p>
<ul>
<li>遇见大于目标数字项即可退出执行</li>
</ul>
<pre><code>def orderSequentialSrarch(alist, item):
    pos = 0
    found = False
    stop = False

    while pos &lt; len(alist) and not found and not stop:
        if alist[pos] == item:
            found = True
        else:
            if alist[pos] &gt; item:
                stop = True
            else:
                pos = pos + 1

    return found

testlist = [0,1,2,8,13,17,19,32,42]
print(orderSequentialSrarch(testlist, 3))
print(orderSequentialSrarch(testlist, 13))
</code></pre>
<h4 id="52-二分查找-olog-n">5.2 二分查找 O(log n)</h4>
<ul>
<li>有序表</li>
<li>分而治之</li>
</ul>
<pre><code>def binarySrarch(alist, item):
    first = 0
    last = len(alist) - 1
    found = False

    while first &lt;= last and not found:
        midpoint = (first + last) // 2
        if alist[midpoint] == item:
            found = True
        else:
            if item &lt; alist[midpoint]: #缩小比对范围
                last = midpoint - 1
            else:
                first = midpoint + 1

    return found

testlist = [0,1,2,8,13,17,19,32,42]
print(binarySrarch(testlist, 3))
print(binarySrarch(testlist, 13))
</code></pre>
<p><strong>5.2.1 二分查找的递归写法</strong></p>
<pre><code>def binarySrarch(alist, item):
    if len(alist) == 0:
        return False
    else:
        midpoint = len(alist) // 2
        if alist[midpoint] == item:
            return True
        else:
            if item &lt; alist[midpoint]:
                return binarySrarch(alist[:midpoint], item)
            else:
                return binarySrarch(alist[midpoint+1:], item)

alist = [0,1,2,8,13,17,19,32,42]
print(binarySrarch(alist, 3))
print(binarySrarch(alist, 13))
</code></pre>
<h4 id="53-冒泡排序-on2">5.3 冒泡排序 O(n^2)</h4>
<ul>
<li>无需任何额外存储空间开销</li>
</ul>
<pre><code>def bubbleSort(alist):
    for passnum in range(len(alist)-1,0,-1):
        for i in range(passnum): #n-1躺
            if alist[i] &gt; alist[i+1]:
                temp = alist[i]
                alist[i] = alist[i+1]
                alist[i+1] = temp
                
#python直接交换： alist[i],alist[i+1]=alist[i+1],alist[i]
    
alist = [54,26,93,17,77,31,44,55,20]
bubbleSort(alist)
print(alist)
</code></pre>
<p><strong>5.3.1 冒泡排序优化</strong></p>
<ul>
<li>通过检测每趟比对，如发现某趟比对没有发生任何交换，说明列表已经排好序，可提前结束算法</li>
</ul>
<pre><code>def shortBubbleSort(alist):
    exchanges = True
    passnum = len(alist)-1
    while passnum &gt; 0 and exchanges:
        exchanges = False
        for i in range(passnum):
            if alist[i]&gt;alist[i+1]:
                exchanges = True
                alist[i],alist[i+1]=alist[i+1],alist[i]
        passnum = passnum - 1

alist = [20,30,40,90,50,60,70,80,100, 110]
shortBubbleSort(alist)
print(alist)
</code></pre>
<h4 id="54-选择排序">5.4 选择排序</h4>
<ul>
<li>记录最大项所在位置</li>
<li>对比次数O(n^2), 交换次数减少为O(n)</li>
</ul>
<pre><code>def selectionSort(alist):
    for fillslot in range(len(alist)-1,0,-1):
        positionOfMax=0
        for location in range(1,fillslot+1):
            if alist[location]&gt;alist[positionOfMax]:
                positionOfMax = location

        alist[fillslot],alist[positionOfMax] = alist[positionOfMax],alist[fillslot]
</code></pre>
<h4 id="55-插入排序-on2">5.5 插入排序 O(n^2)</h4>
<ul>
<li>由于移动操作仅包含1次赋值，是交换操作的三分之一，所以插入排序性能较好</li>
</ul>
<pre><code>def insertionSort(alist):
    for index in range(1,len(alist)):

        currentvalue = alist[index] #新项/插入项
        position = index

        while position&gt;0 and alist[position-1]&gt;currentvalue:
            alist[position]=alist[position-1]
            position = position-1 #对比、移动

        alist[position]=currentvalue # 插入新项
</code></pre>
<h4 id="56-谢尔排序-on23">5.6 谢尔排序 O(n^(2/3))</h4>
<ul>
<li>先对子列表排序，再进行插入排序</li>
<li>间隔一般从n/2开始，每趟倍增：n/4，n/8……直到1</li>
<li>减少无效比对</li>
</ul>
<pre><code>def shellSort(alist):
    sublistcount = len(alist)//2 #间隔设定
    while sublistcount &gt; 0:

        for startposition in range(sublistcount): #子列表排序
            gapInsertionSort(alist,startposition,sublistcount)

        print('After increments of size',sublistcount,'The list is',alist)

        sublistcount = sublistcount // 2 

def gapInsertionSort(alist,start,gap):
    for i in range(start+gap,len(alist),gap):

        currentvalue = alist[i]
        position = i

        while position&gt;=gap and alist[position-gap]&gt;currentvalue:
            alist[position]=alist[position-gap]
            position = position-gap

        alist[position]=currentvalue
</code></pre>
<h4 id="57-归并排序-onlog-n">5.7 归并排序 O(nlog n)</h4>
<ul>
<li>使用额外1倍存储空间<br>
<strong>5.7.1 递归写法</strong></li>
</ul>
<pre><code>def mergeSort(alist):
## print('Splitting ',alist)
    if len(alist)&gt;1: #基本结束条件
        mid = len(alist)//2
        lefthalf = alist[:mid]
        righthalf = alist[mid:]

        mergeSort(lefthalf) #递归调用
        mergeSort(righthalf)

        i= j= k= 0
        while i&lt;len(lefthalf) and j&lt;len(righthalf): #拉链交错把左右半部从小到大归并到结果列表中
            if lefthalf[i]&lt;righthalf[j]:
                alist[k]=lefthalf[i]
                i=i+1
            else:
                alist[k]=righthalf[j]
                j=j+1
            k=k+1

        while i&lt;len(lefthalf): #归并左半部剩余项
            alist[k]=lefthalf[i]
            i=i+1
            k=k+1

        while j&lt;len(righthalf): #归并右半部剩余项
            alist[k]=righthalf[j]
            j=j+1
            k=k+1

    print('Merging ',alist)
</code></pre>
<p><strong>5.7.2 更pythonic写法</strong></p>
<pre><code>def mergeSort(lst):
    #递归结束条件
    if len(lst) &lt;= 1:
        return lst
    #分解问题，递归调用
    middle = len(lst) // 2
    left = mergeSort(lst[:middle])
    right = mergeSort(lst[middle:])
    #合并左右半部，完成排序
    merged = []
    while left and right:
        if left[0] &lt;= right[0]:
            merged.append(left.pop(0))
        else:
            merged.append(right.pop(0))
            
    merge.extend(right if right else left)
    return merged
</code></pre>
<h4 id="58-快速排序-onlog-n">5.8 快速排序 O(nlog n)</h4>
<ul>
<li>依据中值将数据表分为两半(中值选取需避免极值，否则左右两侧数据量不平衡)</li>
</ul>
<pre><code>def quickSort(alist):
    quickSortHelper(alist,0,len(alist)-1)

def quickSortHelper(alist,first,last):
    if first &lt; last: #基本结束条件

        splitpoint = partition(alist,first,last) #分裂
        quickSortHelper(alist,first,splitpoint-1) #递归调用
        quickSortHelper(alist,splitpoint+1,last)

    alist = [54,26,93,17,77,31,44,55,20]
    quickSort(alist)
    print(alist)

def partition(alist,first,last): #选定中值
    pivotvalue = alist[first]

    leftmark = first+1 #左右初始标
    rightmark = last

    done = False
    while not done:

        while leftmark &lt;= rightmark and \
                alist[leftmark] &lt;= pivotvalue: #向右移动左标
            leftmark = leftmark+1

        while alist[rightmark] &gt;= pivotvalue and \
                rightmark &gt;= leftmark: #向左移动右标
            rightmark = rightmark+1

        if rightmark &lt; leftmark:
            done = True
        else:
            alist[leftmark],alist[rightmark] = alist[rightmark],alist[leftmark] #左右标的值交换

    alist[first],alist[rightmark] = alist[rightmark],alist[first] #中值就位

    return rightmark #中值点，也是分裂点
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0413 | 又双叕学python（2）]]></title>
        <id>https://pythonangry.github.io/post/DjCAaxOU_/</id>
        <link href="https://pythonangry.github.io/post/DjCAaxOU_/">
        </link>
        <updated>2020-04-13T03:32:20.000Z</updated>
        <content type="html"><![CDATA[<h4 id="12基本统计值计算">12.基本统计值计算</h4>
<pre><code>def getNum():
    nums = []
    iNumStr = input(&quot;请输入数字（回车退出）：&quot;)
    while iNumStr !=&quot;&quot;:
        nums.append(eval(iNumStr))
        iNumStr = input(&quot;请输入数字（回车退出）：&quot;)
    return nums

def mean(numbers):
    s = 0.0
    for num in numbers:
        s = s + num
    return s / len(numbers)

def dev(numbers, mean):
    sdev = 0.0
    for num in numbers:
        sdev = sdev + (num - mean)**2
    return pow(sdev / (len(numbers)-1), 0.5) #方差公式

def median(numbers):
    sorted(numbers)
    size = len(numbers)
    if size % 2 == 0:
        med = ((numbers[size//2-1]) + numbers[size//2])/2 #从0号位开始取，[1,5]=取前不取后，取1，2，3，4。
    else:
        med = numbers[size//2]
    return med

n = getNum()
m = mean(n)
print('平均值:{},方差:{:.2},中位数:{}'.format(m,dev(n,m),median(n)))
</code></pre>
<h4 id="13哈姆雷特词频统计">13.哈姆雷特词频统计</h4>
<pre><code>def getText():
    txt = open('hamlet.txt','r').read()
    txt = txt.lower()
    for ch in '!&quot;$%&amp;()*+,-./;:&lt;&gt;=?@[\\]^_{|}~`':
        txt = txt.replace(ch, &quot; &quot;)
    return txt

hamletTxt = getText()
words = hamletTxt.split()
counts = {}
for word in words:
    counts[word] = counts.get(word,0) + 1
items = list(counts.items())
items.sort(key=lambda x:x[1], reverse=True)
for i in range(10):
    word, count = items[i]
    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word, count))
</code></pre>
<h4 id="14三国演义人物出场统计">14.三国演义人物出场统计</h4>
<pre><code>import jieba
txt = open('sanguo.txt','r',encoding=utf-8).read()
excludes = {'将军','却说','荆州','二人','不可','不能','如此','...'}
words = jieba.lcut(txt)
counts = {}
for word in words:
    if len(word) == 1:
        continue
    elif word == '诸葛亮' or word == '孔明曰':
        rword = '孔明'
    elif word == '关公' or word == '云长':
        rword = '关羽'
    elif word == '玄德' or word == '玄德曰':
        rword = '刘备'
    elif word == '孟德' or word == '丞相':
        rword = '曹操'
    elif word == '...' or word == '...':
        rword = '..'
    else:
        rword = word
    counts[word] = counts.get(word,0) + 1
for word in excludes:
    del counts[word]
items = list(counts.items())
items.sort(key=lambda x:x[1], reverse=True)
for i in range(10):
    word, count = items[i]
    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word, count))
</code></pre>
<h4 id="15自动轨迹绘制">15.自动轨迹绘制</h4>
<p><strong>基本思路</strong></p>
<ol>
<li>定义数据文件格式（接口）</li>
<li>编写程序，根据文件接口解析参数绘制图形</li>
<li>编制数据文件<br>
<strong>理解方法思维</strong></li>
</ol>
<ul>
<li>自动化思维：数据和功能分离，数据驱动自动运行</li>
<li>接口化设计：格式化设计接口，清晰明了</li>
<li>二维数据应用：应用维度组织数据</li>
</ul>
<pre><code>import turtle as t
t.title('自动轨迹绘制')
t.setup(800,600,0,0)
t.pencolor('red')
t.pensize(5)
# 数据读取
datals = []
f = open('data.txt') #打开数据文件
for line in f:
    line = line.replace('\n','') #将每一行的回车去除
    datals.append(list(map(eval,line.split(',')))) #map函数将eval方法运用到每一个元素当中
f.close() #正确及时关闭文件，若忘记，程序正确运行后也会关闭
# 自动绘制
for i in range(len(datals)): #此时，列表datals由一个个列表元素组成，即二维数据
    #数据接口形式如：300,1,144,0,1,0 分别为行进距离，转向判断（0左转，1右转），转向角度，及RGB三个通道颜色（0-1之间的浮点数）
    t.pencolor(datals[i][3],datals[i][4],datals[i][5])
    t.fd(datals[i][0])
    if datals[i][1]:
        t.right(datals[i][2])
    else:
        t.left(datals[i][2])
</code></pre>
<h4 id="16政府工作报告词云">16.政府工作报告词云</h4>
<pre><code>import jieba
import wordcloud
from imageio import imread
mask = imread('fivestar.png') #运用imread将词云形状进行设定，也可以不设定，默认长方形
f = open('f.txt','r',encoding='utf-8')
t = f.read()
f.close()
ls = jieba.lcut(t) #中文文本需要分词
txt = ' '.join(ls) #把分出来的中文词列表用空格连接形成长字符串
w = wordcloud.WordCloud(font_path = 'msyh.ttc', mask = mask\ #mask方法形成不规则词云
                        width = 1000, height = 700, background_color ='white', \)
w.generate(txt)
w.to_file('growordcloud.png')
</code></pre>
<h4 id="17第七周练习题">17.第七周练习题</h4>
<h5 id="acsv格式清洗与转换">a.CSV格式清洗与转换</h5>
<p>（1）按行进行倒序排列<br>
（2）每行数据倒序排列<br>
（3）使用分号（;）代替逗号（,）分割数据，无空格</p>
<pre><code>f = open('data.csv','r')
lines = f.readlines()
lines.reverse()

for line in lines:
    line = line.replace('\n','')
    line =line.replace(' ','')
    t = line.split(&quot;,&quot;)
    t.reverse()
    print(&quot;;&quot;.join(t))
</code></pre>
<h5 id="b文本的平均列数">b.文本的平均列数</h5>
<p>（1）有效行指包含至少一个字符的行，不计空行<br>
（2）每行的列数为其有效数<br>
（3）平均列数为有效行的列数平均值，采用四舍五入方式取整数进位</p>
<pre><code>f= open('latex.log','r')
bar = 0
chars = 0
for line in f.readlines():
    if not (len(line) == 1  and line[-1]=='\n') :
        bar +=1
        chars += len(line)-1

avg = round(chars/bar,0)
avg = int(avg)
print(avg)‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪
</code></pre>
<h5 id="c第七周选做习题">c.第七周选做习题</h5>
<p><img src="https://pythonangry.github.io/post-images/1586747620320.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748303359.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748612258.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748669253.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748723905.png" alt="" loading="lazy"></p>
<h4 id="18体育竞技分析">18.体育竞技分析</h4>
<ul>
<li>计算思维：抽象+自动化</li>
<li>模拟：抽象比赛过程+自动化执行N场比赛</li>
<li>当N越大，比赛结果分析越科学<br>
<strong>（1）自顶向下（设计）</strong></li>
<li>将一个总问题表达为若干小问题组成的形式</li>
<li>使用同样方法进一步分析小问题<br>
<strong>（2）自底向上（执行）</strong></li>
<li>分单元测试，逐步组装</li>
<li>按自顶向下相反的路径操作</li>
<li>直至系统各部分以组装的思路都经过测试和验证</li>
</ul>
<hr>
<p><strong>程序总体框架及步骤</strong></p>
<ul>
<li>步骤1：打印程序介绍信息 ——printInfo()</li>
<li>步骤2：获得程序运行参数：proA，proB，n ——getInputs()</li>
<li>步骤3：利用球员A和B的能力值，模拟n局比赛 ——simNGames()</li>
<li>步骤4：输出球员A和B获胜比赛的场次及概率 ——printSummary()</li>
</ul>
<pre><code>from random import random

def main():
    printIntro()
    proA, proB, n = getInputs()
    winsA, winsB = simNGames(n, proA, proB)
    printSummary(winsA, winsB)

def printIntro():
    print('this game is between A and B')
    print('the value of A and B are needed')

def getInputs():
    a = eval(input('please input value A:'))
    b = eval(input('please input value B:'))
    n = eval(input('game would be run:'))
    return a, b, n

def printSummary(winsA, winsB):
    n = winsA + winsB
    print('game run {}'.format(n))
    print('A wins {}, as{:0.1%}'.format(winsA, winsA/n))
    print('B wins {}, as{:0.1%}'.format(winsB, winsB/n))

def simNGames(n, proA, proB):
    winsA, winsB = 0, 0
    for i in range(n):
        scoreA, scoreB = simOneGame(proA, proB) #模拟一局比赛
        if scoreA &gt; scoreB:
            winsA += 1
        else:
            winsB += 1
    return winsA, winsB

def simOneGame(proA, proB):
    scoreA, scoreB = 0, 0
    serving = 'A'
    while not gameOver(scoreA, scoreB):
        if serving == 'A':
            if random() &lt; proA:
                scoreA +=1
            else:
                serving ='B'
        else:
            if random() &lt; proB:
                scoreB +=1
            else:
                serving = 'A'
    return scoreA, scoreB

def gameOver(a,b):
    return a==15 or b==15

main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0404 | 统计学]]></title>
        <id>https://pythonangry.github.io/post/HoJsDOlnB/</id>
        <link href="https://pythonangry.github.io/post/HoJsDOlnB/">
        </link>
        <updated>2020-04-04T01:33:11.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://pythonangry.github.io/post-images/1585964012087.png" alt="" loading="lazy"><br>
标准差的自由值<br>
<img src="https://pythonangry.github.io/post-images/1586004274765.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1585964025232.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0403 | 数据结构与算法（1）]]></title>
        <id>https://pythonangry.github.io/post/LFgTZAtp8/</id>
        <link href="https://pythonangry.github.io/post/LFgTZAtp8/">
        </link>
        <updated>2020-04-03T02:22:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1算法分析">1算法分析</h3>
<figure data-type="image" tabindex="1"><img src="https://pythonangry.github.io/post-images/1585966998751.png" alt="" loading="lazy"></figure>
<h4 id="11变位词判断问题">1.1变位词判断问题</h4>
<p><strong>1.1.1 逐字检查 O(n^2)</strong></p>
<ul>
<li>两重循环，外层遍历s1每个字符，将内层循环执行n次</li>
<li>内层循环在s2查找字符，每个字符对比次数从1-N，各不相同</li>
</ul>
<pre><code>def anagramSolution1(s1,s2):
    alist = list(s2) #复制s2到列表
    pos1 = 0
    stillOK = True
    while pos1 &lt; len(s1) and stillOK:
        pos2 = 0
        found = False
        while pos2 &lt; len(alist) and not found: #循环s1每一个字符
            if s1[pos1] == alist[pos2]: #与s2逐个对比
                found = True
            else:
                pos2 = pos2 +1
        if found:
            alist[pos2] = None #找到，打勾设为空
        else:
            stillOK = False #没找到，失败
        pos1 = pos1 +1
    return stillOK

print(anagramSolution1('abcd','dcba'))
</code></pre>
<p><strong>1.1.2 排序比较 O(nlogn)</strong></p>
<ul>
<li>本算法主导步骤是排序步骤</li>
</ul>
<pre><code>def anagramSolution2(s1,s2):
    alist1 = list(s1)
    alist2 = list(s2)
    
    alist1.sort()
    alist2.sort()
    pos = 0
    matches = True
    while pos &lt; len(s1) and matches:
        if alist1[pos] == alist2[pos]:
                pos = pos +1
        else:
            matches = False
    return matches

print(anagramSolution2('abcde','edcba'))
</code></pre>
<p><strong>1.1.3 暴力法 O(n!)</strong></p>
<ul>
<li>穷尽所有可能的组合</li>
<li>将s1出现的字符进行全排列，查看s2是否出现在全排列列表中</li>
</ul>
<p><strong>1.1.4 计数比较 O(n)</strong></p>
<ul>
<li>3个非嵌套循环迭代</li>
<li>依赖26计数器列表，储存空间用量最多，问题解法需要取舍权衡时间与空间</li>
</ul>
<pre><code>def anagramSolution4(s1,s2):
    c1 = [0] * 26 #26个0的列表
    c2 = [0] * 26
    for i in range(len(s1)): #分别计算
        pos = ord(s1[i]) - ord('a') #ord('a')=97 b98...
        c1[pos] = c1[pos] +1
    for i in range(len(s2)):
        pos = ord(s1[i]) - ord('a')
        c2[pos] = c2[pos] +1
    j = 0
    stillOK = True
    while j &lt; 26 and stillOK: #计数器比较
        if c1[j] == c2[j]:
            j = j + 1
        else:
            stillOK = False
    return stillOK

print(anagramSolution4('apple','pleap'))
</code></pre>
<h3 id="2python数据类型性能">2Python数据类型性能</h3>
<p>总方案：让最常用的操作性能最好<br>
官方算法复杂度网站:<a href="https://wiki.python.org/moin/TimeComplexity"></a></p>
<h3 id="3线性结构">3线性结构</h3>
<ul>
<li>有序，除第一个与最后一个，中间数据有唯一的前驱和后继，新增数据只会加到原有某数据之前或之后</li>
</ul>
<h4 id="31栈">3.1栈</h4>
<ul>
<li>数据加入和移除都仅发生在同一端</li>
<li>距离栈底越近的数据项，留在栈中的时间越长</li>
<li>后进先出LIFO</li>
<li>特性：反转次序[浏览器后退][文档撤销]</li>
<li>通常选用list末端(index = 1-)作为栈顶<br>
<strong>3.1.1 括号匹配</strong><br>
a.简单括号匹配</li>
</ul>
<pre><code>from pythonds import Stack

def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index &lt; len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol == '(':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                s.pop()

        index = index + 1

    if balanced and s.isEmpty():
        return True
    else:
        return False

print(parChecker('((()))'))
print(parChecker('(()'))
</code></pre>
<p>b.通用括号匹配</p>
<pre><code>from pythonds import Stack

def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index &lt; len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol in '([{':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                top = s.pop()
                if not matches(top,symbol):
                    balanced = False
        index = index + 1
    if balanced and s.isEmpty():
        return True
    else:
        return False

def matches(open,close):
    opens = '([{'
    closers = ')]}'
    return opens.index(open) == closers.index(close) #查询值的位置查看是否相等

print(parChecker('({}{[}})'))
print(parChecker('{[()]()}'))
</code></pre>
<p><strong>3.1.2进制转换</strong><br>
a.十进制转换为二进制<br>
转换过程中余数从在栈中排列从上端到下端看为从低到高，<br>
出栈时则需要从高到低排列，正好符合栈的特性</p>
<pre><code>from pythonds import Stack

def divideBy2(decNumber):
    remstack = Stack()

    while decNumber &gt; 0:
        rem = decNumber % 2 #求余数
        remstack.push(rem)
        decNumber = decNumber // 2 #整除数

    binString = ''
    while not remstack.isEmpty():
        binString = binString + str(remstack.pop())

    return binString

print(divideBy2(42))
</code></pre>
<p>b.十进制转换为十六以下任意进制</p>
<pre><code>from pythonds import Stack

def baseConverter(decNumber,base):
    digits = '0123456789ABCDEF'

    remstack = Stack()

    while decNumber &gt; 0:
        rem = decNumber % base #求余数
        remstack.push(rem)
        decNumber = decNumber // base #整除数

    newString = ''
    while not remstack.isEmpty():
        newString = newString + digits[remstack.pop()] #索引位置返回值

    return newString

print(baseConverter(25,2))
print(baseConverter(19920,16))
</code></pre>
<p><strong>3.1.3表达式转换</strong></p>
<ul>
<li>全括号表达式：把运算符移到右或左括号位置替代即可变为后缀或前缀形式</li>
<li>中缀、前缀和后缀表达式<br>
a.中缀表达式转换为后缀表达式</li>
</ul>
<pre><code>from pythonds import Stack

def infixToPostfix(infixexpr):
    prec = {}
    prec['*'] = 3 #记录操作符优先级
    prec['/'] = 3
    prec['+'] = 2
    prec['-'] = 2
    prec['('] = 1
    opStack = Stack()
    postfixList = []
    tokenList = infixexpr.split() #解析表达式到单词列表

    for token in tokenList:
        if token in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' or token in '0123456789': #操作数
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            toptoken = opStack.pop()
            while toptoken != '(':
                postfixList.append(toptoken)
                toptoken = opStack.pop()
        else:                                                #操作符
            while (not opStack.isEmpty()) and \
                    (prec[opStack.peek()] &gt;= prec[token]):
                        postfixList.append(opStack.pop())
            opStack.push(token)

    while not opStack.isEmpty():
        postfixList.append(opStack.pop())    #操作符
    return ' '.join(postfixList)   #合成后缀表达式字符串
</code></pre>
<p>b.后缀表达式求值</p>
<pre><code>from pythonds import Stack

def postfixEval(postfixExpr):
    operandStack = Stack()
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token in  '0123456789': #操作数
            operandStack.push(int(token))
        else:
            operand2 = operandStack.pop()
            operand1 = operandStack.pop()
            result = doMath(token, operand1, operand2)
            operandStack.push(result)
    return operandStack.pop()

def doMath(op, op1, op2):
    if op == '*':
        return op1 * op2
    elif op == '/':
        return op1 / op2
    elif op == '+':
        return op1 + op2
    else:
        return op1 - op2
</code></pre>
<p><strong>3.1.4 一维消消乐</strong></p>
<pre><code>from pythonds import Stack

def remover(symbolString):
    s = Stack()
    index = 0
    str = []
    while index &lt; len(symbolString):
        symbol = symbolString[index]
        if s.isEmpty():
            s.push(symbol)
        elif not s.isEmpty():
            if symbol == s.peek():
                s.pop()
            else:
                s.push(symbol)
        index +=1
    if s.isEmpty():
        str = ''.join(&quot;None&quot;)
        return str
    else:
        while not s.isEmpty():
            str.append(s.pop())
        return ''.join(str[::-1])

print(remover('abba'))
print(remover('abbacd'))
</code></pre>
<ul>
<li>可以直接join stack中的元素（''.join(s.items)），不需要pop出来倒叙，stack本质上的定义仍为一个列表</li>
</ul>
<pre><code>from pythonds import Stack

s = Stack()
def remover(symbolString):
    index = 0
    while index &lt; len(symbolString):
        symbol = symbolString[index]
        if s.isEmpty():
            s.push(symbol)
        elif not s.isEmpty():
            if symbol == s.peek():
                s.pop()
            else:
                s.push(symbol)
        index +=1
    return ''.join(s.items)

if not s.isEmpty:
    print(s)
else:
    print('None',end='')

print(remover('abba'))
print(remover('accbcf'))
</code></pre>
<h4 id="32-队列">3.2 队列</h4>
<p><strong>3.2.1 热土豆</strong></p>
<pre><code>def hotpotato(namelist, num):
    simqueue = Queue()
    for name in namelist:
        simqueue.enqueue(name)

    while simqueue.size() &gt; 1:
        for i in range(num):
            simqueue.enqueue(simqueue.dequeue()) #一次传递

        simqueue.dequeue()

    return simqueue.dequeue()

print(hotpotato(['bill','david','susan','jane','kent','bard'],7))
</code></pre>
<p><strong>3.2.2 打印任务</strong><br>
复习！自己重新输出思路！</p>
<p><strong>3.2.1 回文词</strong></p>
<pre><code>from pythonds import Deque #双端队列

def palchecker(aString):
    chardeque = Deque()

    for ch in aString:
        chardeque.addRear(ch) # asdf → rear · fdsa · front

    stillEqual = True

    while chardeque.size() &gt; 1 and stillEqual:
        first = chardeque.removeFront()
        last = chardeque.removeRear()
        if first != last:
            stillEqual = False

    return stillEqual

print(palchecker('sfderrd'))
print(palchecker('radar'))
</code></pre>
<h4 id="33链表">3.3链表</h4>
<p><strong>3.3.1 无序表</strong></p>
<pre><code>class Node:
    def __init__(self,initdata):
        self.data = initdata
        self.next = None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data = newdata

    def setNext(self,newnext):
        self.next = newnext

class UnorderList:

    def __init__(self):
        self.head = None

def add(self,item): #add方法实现
    temp = Node(item)
    temp.setNext(self.head) #链接次序不能反
    self.head = temp

def size(self): #size的实现
    current = self.head
    count = 0
    while current != None:
        count = count + 1
        current = current.getNext()

    return count

def search(self,item): #seatch的实现
    current = self.head
    found = False
    while current != None and not found:
        if current.getData() == item:
            fount = True
        else:
            current = current.getNext()

    return found

def remove(self,item): #remove（item）方法
    current = self.head
    previous = None
    found = False
    while not found:
        if current.getData() == item:
            found = True
        else:
            previous = current
            current = current.getNext()

    if previous == None: #第一个就找到，要remove
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
</code></pre>
<p><strong>3.3.2 有序表</strong></p>
<pre><code>def add(self,item): #找到第一个比他大的就可以加入
    current = self.head
    previous = None
    stop = False
    while current != None and not stop:
        if current.getData() &gt; item: #发现插入位置
            stop = True
        else:
            previous = current
            current = current.getNext

    temp = Node(item)
    if previous == None: #插在表头
        temp.setNext(self.head)
        self.head = temp
    else:                  #插在表中
        temp.setNext(current)
        previous.setNext(temp)
</code></pre>
<h3 id="4-递归">4 递归</h3>
<p><strong>递归三定律</strong></p>
<ul>
<li>基本结束条件，解决最小规模问题</li>
<li>缩小规模，向基本结束条件演进</li>
<li>调用自身来解决已缩小规模的相同问题</li>
</ul>
<h4 id="41-递归的应用">4.1 递归的应用</h4>
<p><strong>4.1.1 任意进制转换</strong></p>
<ul>
<li>基本结束条件：余数小于进制基base</li>
<li>更小规模问题：整数商</li>
</ul>
<pre><code>def toStr(n, base):
    converString = '0123456789ABCDEF'
    if n &lt; base:
        return converString[n] #最小规模
    else:
        return toStr(n//base, base) + converString[n%base] #调用自身
print(toStr(1453, 16))
</code></pre>
<p><strong>4.1.2 海龟作图</strong><br>
a. 螺旋</p>
<pre><code>import turtle

t = turtle.Turtle()

def drawSpiral(t, lineLen):
    if lineLen &gt; 0: #最小规模，0直接退出
        t.forward(lineLen)
        t.right(90)
        drawSpiral(t, lineLen - 5) #减少规模调用自身，边长减5

drawSpiral(t, 100)

turtle.done()
</code></pre>
<p>b. 分形树</p>
<pre><code>import turtle

def tree(branch_len):
    if branch_len &gt; 5: #树干太短不画，基本结束条件
        t.forward(branch_len) #画树干
        t.right(20) #右倾斜20度
        tree(branch_len - 15) #递归调用，画右边小树，树干减15
        t.left(40) #向左回40度
        tree(branch_len - 15) #递归调用，画左边小树，树干减15
        t.right(20) #向左回20度，即回正
        t.backward(branch_len) #海龟退回原位置

t = turtle.Turtle()
t.left(90)
t.penup()
t.backward(100)
t.pendown()
t.pencolor('green')
t.pensize(2)
tree(100) #画树干长度75的二叉树
t.hideturtle()
turtle.done()
</code></pre>
<p>c.谢尔宾斯基Sierpinski三角形</p>
<pre><code>import turtle

def sierpinski(degree, points):
    colormap = ['blue','red','green','white','yellow','orange','gray','pink']
    drawTriangle(points, colormap[degree]) #等边三角形
    if degree &gt;  0: #基本结束条件
        sierpinski(degree - 1,
                   {'left': points['left'],
                    'top':getMid(points['left'], points['top']), #减小规模：getMid边长减半，调用自身，左上右次序
                    'right':getMid(points['left'], points['right'])})
        sierpinski(degree - 1,
                   {'left': getMid(points['left'], points['top']),
                    'top': points['top'],
                    'right': getMid(points['top'], points['right'])})
        sierpinski(degree - 1,
                   {'left': getMid(points['left'], points['right']),
                    'top': getMid(points['top'], points['right']),
                    'right': points['right']})

def drawTriangle(points, color): #绘制等边三角形
    t.fillcolor(color)
    t.penup()
    t.goto(points['top'])
    t.pendown()
    t.begin_fill()
    t.goto(points['left'])
    t.goto(points['right'])
    t.goto(points['top'])
    t.end_fill()

def getMid(p1, p2): #取两个点的中点
    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2 )

t = turtle.Turtle()

points = {'left':(-200, -100), #外轮廓三个顶点
          'top':(0, 200),
          'right':(200, -100)}
sierpinski(7, points) #7阶Sierpinski triangle
</code></pre>
<p>d.汉诺塔</p>
<ul>
<li>将最上层N-1个盘片从开始柱，经由目标柱，移动到中间柱</li>
<li>将第N个（最大的）盘片，从开始柱，移动到目标柱</li>
<li>将放在中间柱的N-1个盘片，经由开始柱，移动到目标柱</li>
</ul>
<pre><code>def moveTower(height, fromPole, withPole, toPole):
    if height &gt;= 1:
        moveTower(height - 1, fromPole, toPole, withPole)
        moveDisk(height, fromPole, toPole)
        moveTower(height - 1, withPole, fromPole, toPole)

def moveDisk(disk, fromPole, toPole):
    print(f'Moving disk[{disk}] from {fromPole} to {toPole}')

moveTower(3, '#1', '#2', '#3')
</code></pre>
<p>e.探索迷宫（表示投降）</p>
<h4 id="42优化递归策略">4.2优化递归策略</h4>
<p><strong>4.2.1 分治策略</strong></p>
<ul>
<li>解决问题的典型策略：分而治之</li>
</ul>
<p><strong>4.2.2 贪心策略</strong></p>
<ul>
<li>每次选择尽量大的部分一次解决<br>
a.找零兑换递归解法</li>
</ul>
<pre><code>def recMC(coinValueList, change):
    minCoins = change
    if change in coinValueList:
        return 1 #最小规模，直接返回
    else:
        for i in [c for c in coinValueList if c &lt;= change]:
            numCoins = 1 + recMC(coinValueList, change-i) #调用自身，减少规模：每次减去一种硬币面值，挑选最小数量
            if numCoins &lt; minCoins:
                minCoins = numCoins
    return minCoins

print(recMC([1,5,10,25], 63))
</code></pre>
<p>a`.找零兑换贪心解法</p>
<ul>
<li>求优化问题的一类算法</li>
<li>遍历备选元素</li>
<li>贪心策略确定选择一个元素<br>
B站<a href="https://www.bilibili.com/video/BV18Q4y1K7px?from=search&amp;seid=11522479327303874531">Ch8.1_贪心算法（硬币找零）_算法设计与分析Python</a></li>
</ul>
<pre><code>def getMinCoins(change):
    coins = [1, 5, 10 ,25]
    solution = []

    s_coins = sorted(coins, reverse=True)
    for c in s_coins:
        num_coin = int (change/c)
        solution +=[c, ]*num_coin

        change = change - c*num_coin
        if change &lt;= 0:
            break

    return solution

print(getMinCoins(63))
</code></pre>
<p><strong>4.2.3 动态规划</strong><br>
B站<a href="https://www.bilibili.com/video/BV18x411V7fm?from=search&amp;seid=5220760526841036340">动态规划 (第1讲)</a>;<a href="https://www.bilibili.com/video/BV12W411v7rd/?spm_id_from=333.788.videocard.0">动态规划 (第2讲)</a></p>
<ul>
<li>选与不选<br>
a.选择不相邻数字使和最大</li>
<li>递归分析<br>
<img src="https://pythonangry.github.io/post-images/1587521626140.jpg" alt="" loading="lazy"></li>
<li>递归解法<br>
<img src="https://pythonangry.github.io/post-images/1587521690387.jpg" alt="" loading="lazy"></li>
<li>动态规划<br>
<img src="https://pythonangry.github.io/post-images/1587521703716.jpg" alt="" loading="lazy"></li>
</ul>
<p>b.选择数组元素，和等于给定数字</p>
<ul>
<li>递归分析<br>
<img src="https://pythonangry.github.io/post-images/1587521842847.jpg" alt="" loading="lazy"></li>
<li>递归解法<br>
<img src="https://pythonangry.github.io/post-images/1587521853538.jpg" alt="" loading="lazy"></li>
<li>动态规划<br>
<img src="https://pythonangry.github.io/post-images/1587521908802.jpg" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1587521920417.jpg" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1587522064726.jpg" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0329 | Python组合数据类型比较]]></title>
        <id>https://pythonangry.github.io/post/MsFpeHMq-/</id>
        <link href="https://pythonangry.github.io/post/MsFpeHMq-/">
        </link>
        <updated>2020-03-29T07:48:14.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://pythonangry.github.io/post-images/1585468119942.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1585468128764.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1585468135760.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0313 | 又双叕学python（1）]]></title>
        <id>https://pythonangry.github.io/post/1j3QsQSxV/</id>
        <link href="https://pythonangry.github.io/post/1j3QsQSxV/">
        </link>
        <updated>2020-03-13T09:23:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="需求解决">需求解决</h3>
<ol>
<li>实现多个同类网页同时搜索同一关键字</li>
<li>实现多行书籍ISBN导入，连续在商查网页搜索柜位，并返回相应结果至对应ISBN行柜位 *已解决4.17</li>
</ol>
<h3 id="学习工具">学习工具</h3>
<h4 id="相关网站">相关网站</h4>
<ul>
<li>Python社区：http://pypi.org/</li>
</ul>
<h4 id="算法练习">算法练习</h4>
<ul>
<li>https://leetcode-cn.com/</li>
</ul>
<h4 id="dir-help">dir(); help()</h4>
<ol>
<li>爬虫庫</li>
</ol>
<ul>
<li><a href="http://www.python-requests.org/">requests庫</a></li>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc">BeautifulSoup庫</a>：一个可以从HTML或XML文件中提取数据的Python庫</li>
<li><a href="https://docs.python.org/3.5/library/re.html">re正则表达式</a>：进行各类正则表达式处理</li>
<li><strong>爬虫协议:</strong> 网页地址/robots.txt #爬虫需留意不犯法</li>
</ul>
<ol start="2">
<li><a href="http://regex101.com">正则表达式验证网</a></li>
</ol>
<ul>
<li>500.2434: \d{1,}.\d{1,} #1到无穷数字, <strong>.</strong> 匹配 <strong>.</strong>,\d用[0-9]亦可</li>
<li>Test Sentence: [a-zA-z]{1,}</li>
<li>198.3.43.2:(?:\d{1,3}.){3} #**?😗*不捕获最后一个匹配</li>
</ul>
<p><strong>函数式编程</strong>：map()<br>
<strong>一一对应生成字典</strong>：zip()</p>
<h3 id="用python处理数据">用python处理数据</h3>
<h4 id="1清洗咖啡列表">1.清洗咖啡列表</h4>
<pre><code>def cleanList(lst):
    cleanedList = []
    for item in lst:
        for c in item:
            if c.isalpha() != True:
                item = item.replace(c,'')
        cleanedList.append(item)
    return cleanedList

coffeeList = ['32Latte','+Americano30','/34Cappuccino','Mocha35']
cleanedList = cleanList(coffeeList)
for k,v in zip(range(1,len(cleanedList)+1),cleanedList):
    print(k,v)
</code></pre>
<hr>
<h3 id="python爬虫">python爬虫</h3>
<h4 id="1-爬豆瓣短评">1. 爬豆瓣短评</h4>
<pre><code>import requests
from bs4 import BeautifulSoup
headers={'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'}
#加headers反反爬，在浏览器打上about://virsion查询，修改前无返回结果，于是print（r）
获得[418]：The HTTP 418 I’m a teapot client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference to Hyper Text Coffee Pot Control Protocol which was an April Fools’ joke in 1998.
r = requests.get('https://book.douban.com/subject/1084336/comments/',headers=headers)
soup = BeautifulSoup(r.text,'lxml') #将之前get到的对象r.text作为一个参数传入bs函数，获得一个bs对象soup
pattern = soup.find_all('span','short') #通过findall方法寻找评论所在的行，这个方法会返回一个列表。源代码中评论行的标签为span，属性为short。
for item in pattern: #遍历列表中的每一个项
    print(item.string)
</code></pre>
<h4 id="2爬豆瓣评分显然没爬到">2.爬豆瓣评分（显然没爬到）</h4>
<pre><code>import requests
from bs4 import BeautifulSoup
import re
headers={'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'}
r = requests.get('https://book.douban.com/subject/1084336/comments/',headers=headers)
soup = BeautifulSoup(r.text,'lxml') 
pattern = soup.find_all('span','short') 
for item in pattern: 
    print(item.string)
pattern_s = re.compile('&lt;span class = “user-stars allstar(.*?) rating&gt;”') #用compile把字符串编译为pattern实例,.*?利用正则表达式获取字符串当中的评分内容
p = re.findall(pattern_s, r.text) #结果返回列表P
s=0
for star in p:
    s+=int(star)
print(s)

</code></pre>
<h4 id="3-动态网页爬取">3. 动态网页爬取</h4>
<p>使用<strong>开发者工具</strong></p>
<hr>
<h3 id="2019年9月第一次尝试学习de笔记">2019年9月第一次尝试学习de笔记</h3>
<pre><code>类
对象
属性
方法

print(a // b)  #除完取整
print(a % b)   #余数
print(a ** b)  #a的b次方

# %d 整数
# %f 带小数

# int()：将一个数值或字符串转换成整数，可以指定进制。
# float()：将一个字符串转换成浮点数。
# str()：将指定的对象转换成字符串形式，可以指定编码。
# chr()：将整数转换成该编码对应的字符串（一个字符）。
# ord()：将字符串（一个字符）转换成对应的编码（整数）。

# print ('%.1f' % (c)) #将c保留1位小数

# getpass 模块
# random模块的randint(随机数都应是int整数)函数生成指定范围的随机数
# 如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环

# i=1
# j=0
# num = int(input())
# while i &lt;= num-1 :
#     print (i)
#     i = i + j
#     j = i + j

# def fib(n):
#     a, b = 0, 1
#     for _ in range(n):
#         a, b = b, a + b
#         yield a

# Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索

# def main():
#     # Todo: Add your code here
#     pass
#
#
# if __name__ == '__main__':
#     main()
</code></pre>
<hr>
<h3 id="中国mooc北京理工大学python语言程序设计">中国MOOC北京理工大学Python语言程序设计</h3>
<h4 id="知识点摘录">知识点摘录</h4>
<ul>
<li>evla可以去掉字符串或字符串变量的引号</li>
<li>print(&quot;fff:&quot;,i)  #逗号有形成空格的作用 = fff: i</li>
<li>range(N)产生0到N-1个数；(M,N)产生M到N-1个数</li>
<li>整数→浮点数→复数，123+4.0=127.0（数值的范围扩大为浮点数）</li>
<li>槽{}，只在字符串中有用</li>
<li>利用随机数种子生成“确定”的随机数，以便采用随机数的程序能够重演</li>
<li>紧耦合，松耦合 ：函数内紧耦合，函数间松耦合，紧耦合代码复用较为困难，一改全改</li>
</ul>
<h4 id="1温度转换">1.温度转换</h4>
<pre><code>TempStr = input()
if TempStr[-1] in ['F', 'f']:
     C = (eval(TempStr[0:-1]) - 32)/1.8
     print(&quot;{:.2f}C&quot;.format(C))
elif TempStr[-1] in ['C', 'c']:
     F = 1.8*eval(TempStr[0:-1]) + 32
     print(&quot;{:.2f}F&quot;.format(F))
else:
     print(&quot;输入格式错误&quot;)
</code></pre>
<h4 id="2货币转换">2.货币转换</h4>
<pre><code>money = input()
if money[0] in ['R']:  #记得加:
     USD = eval(money[3:])/6.78
     print(&quot;USD{:.2f}&quot;.format(USD))  #记得加引号
elif money[0] in ['U']:
     RMB = eval(money[3:])*6.78
     print(&quot;RMB{:.2f}&quot;.format(RMB))
</code></pre>
<h4 id="3数字一一对应替换">3.数字一一对应替换</h4>
<pre><code>table = ''.maketrans(&quot;abcdefghij&quot;,&quot;1234567890&quot;)  # 创建映射表，注意字符串的长度要一致，达到一一对应的目的
str = &quot;hello world! i love python&quot;
str.translate(table)  # 按照关系表将sting中的字符逐个进行替换
</code></pre>
<h4 id="4turtle可恶的蟒蛇">4.Turtle:可恶的蟒蛇</h4>
<pre><code>import turtle as t
t.setup(650,350,200,200)  #setup()设置窗体大小及位置。宽，高，x，y。
t.penup()  #t.pu()
t.fd(-250)  #海龟的正前方向运行t.fd(d)
t.pendown()  #t.pd()
t.pensize(25)  #t.width()
t.pencolor('purple')  #purple要小写
t.seth(-40)  #改变海龟行进方向，不作画，逆时针40度
for i in range(4):
    t.circle(40,80)  #以海龟当前某点为圆心进行曲线运行turtle.circle(r,angle), r为半径，圆心在turtle左方r距离处，绘制弧度为angle，90则绘制90度弧线
    t.circle(-40,80)
t.circle(40,80/2)
t.fd(40)
t.circle(16,180)
t.fd(40*2/3)
t.done()  #加了此行代码程序不会自动退出
</code></pre>
<h4 id="turtle知识点">turtle知识点</h4>
<p>turtle分绝对方向，绝对角度，和海龟方向，海龟角度<br>
turtle.goto(x,y) #让龟龟去窗体内的任何一个位置<br>
turtle.left(angle)  #龟龟自己的方向角度<br>
turtle库默认采用RGB小数值表示颜色turtle.colormode(mode) mode=1.0或255<br>
<strong>from turtle import</strong>*</p>
<h4 id="5天天向上的力量">5.天天向上的力量</h4>
<pre><code>def dayUP(df):
    dayup = 1
    for i in range(365):
        if i % 7 in [0,6]:
            dayup = dayup * (1-0.01)
        else:
            dayup = dayup * (1+df)
    return dayup
dayfactor = 0.01
while dayUP(dayfactor) &lt; 37.78: #每天努力百分之一一年下来会有37.78值
    dayfactor += 0.001
print(&quot;工作日的努力参数是{:.3f}&quot;.format(dayfactor))
</code></pre>
<h4 id="6文本进度条">6.文本进度条</h4>
<pre><code>import time
scale = 50
print(&quot;执行开始&quot;.center(scale//2,'-'))
start = time.perf_counter()
for i in range(scale+1):
    a = '*' * i
    b = '.' * (scale-i)
    c = (i/scale)*100
    dur = time.perf_counter() - start
    print(&quot;\r{:^3.0f}%[{}-&gt;{}]{:.2f}s&quot;.format(c,a,b,dur))
    time.sleep(0.1)
print(&quot;\n&quot;&quot;执行结束&quot;.center(scale//2,'-'))
</code></pre>
<h4 id="7bmi">7.BMI</h4>
<pre><code>height, weight = eval(input('请输入身高(米)和体重(公斤)[逗号隔开]：'))
bmi = weight / pow(height,2)
print(&quot;BMI数值为：{:.2f}&quot;.format(bmi))
who, nat = &quot;&quot;,&quot;&quot;
if bmi &lt; 18.5:
  who, nat = &quot;偏瘦&quot;, &quot;偏瘦&quot;
elif 18.5 &lt;= bmi &lt;24:
  who, nat = &quot;正常&quot;, &quot;正常&quot;
elif 24 &lt;= bmi &lt; 25:
  who, nat = &quot;正常&quot;, &quot;偏胖&quot;
elif 25 &lt;= bmi &lt; 28:
  who, nat = &quot;偏胖&quot;, &quot;偏胖&quot;
elif 28 &lt;= bmi &lt; 30:
  who, nat = &quot;偏胖&quot;, &quot;肥胖&quot;
else:
  who, nat = &quot;肥胖&quot;, &quot;肥胖&quot;
print(&quot;BMI指标为：国际'{}',国内'{}'&quot;.format(who,nat))
</code></pre>
<h4 id="continue-break">continue， break</h4>
<p>for c in &quot;PYTHON&quot; :<br>
if c == &quot;T&quot;:<br>
continue # 跳过当次循环，不跳过当前循环  break # 跳出循环<br>
print(c,end=&quot;&quot;)</p>
<h4 id="8蒙特卡罗法求解派-面积撒点">8.蒙特卡罗法求解派 # 面积撒点</h4>
<pre><code>from random import random
from time import perf_counter
darts = 1000*1000
hits = 0.0
start = perf_counter()
for i in range (1,darts+1):
  x, y = random(), random()
  dist = pow(x**2+y**2, 0.5)
  if dist &lt;=1.0:
    hits+= 1
pi = 4 * (hits/darts)
print(&quot;圆周率值为{}&quot;.format(pi))
print('运行时间为{:.5f}s'.format(perf_counter()-start))
</code></pre>
<h4 id="9七段数码管绘制">9.七段数码管绘制</h4>
<pre><code>import turtle
def drawLine(draw): #绘制单段数码管
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    turtle.right(90)
def drawDigit(digit): #根据数字绘制七段数码管
    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,6,8] else drawLine(False)
    turtle.left(90)
    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)
    turtle.left(180)
    turtle.penup() #为绘制后续数字确定位置
    turtle.fd(20)
def drawDate(date): #获得要输出的数字
    for i in date:
        drawDigit(eval(i))
def main():
    turtle.setup(800,350,200,200)
    turtle.penup()
    turtle.fd(-300)
    turtle.pensize(5)
    drawDate(&quot;20200319&quot;)
    turtle.hideturtle()
    turtle.done()
main()
</code></pre>
<p>=========================================</p>
<pre><code>import turtle,time
def drawGap():
    turtle.penup()
    turtle.fd(5)
def drawLine(draw): #绘制单段数码管
    drawGap()
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    drawGap()
    turtle.right(90)
def drawDigit(digit): #根据数字绘制七段数码管
    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,6,8] else drawLine(False)
    turtle.left(90)
    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)
    turtle.left(180)
    turtle.penup() #为绘制后续数字确定位置
    turtle.fd(20)
def drawDate(date): #获得要输出的数字
    turtle.pencolor('red')
    for i in date:
        if i =='-':
            turtle.write('年',font=('Arial',18,'normal'))
            turtle.pencolor('green')
            turtle.fd(40)
        elif i =='=':
            turtle.write('月', font=('Arial', 18, 'normal'))
        elif i =='+':
            turtle.write('日', font=('Arial', 18, 'normal'))
        else:
            drawDigit(eval(i))
def main():
    turtle.setup(800,350,200,200)
    turtle.penup()
    turtle.fd(-300)
    turtle.pensize(5)
    drawDate(time.strftime(&quot;%y-%m=%d+&quot;,time.gmtime()))
    turtle.hideturtle()
    turtle.done()
main()
</code></pre>
<h4 id="10科赫雪花">10.科赫雪花</h4>
<pre><code>import turtle,time
def koch (size,n):
    if n == 0:
        turtle.fd(size)
    else:
        for angle in [0,60,-120,60]:
            turtle.left(angle)
            koch(size/3,n-1)
def main():
    turtle.setup(600,600)
    turtle.penup()
    turtle.goto(-200,100)
    turtle.pendown()
    turtle.pensize(2)
    level = 2 # 2阶科赫雪花，阶数
    koch(400,level)
    turtle.right(120)
    koch(400, level)
    turtle.right(120)
    koch(400, level)
    turtle.hideturtle()
main()
</code></pre>
<h4 id="11第五周练习题">11.第五周练习题</h4>
<p><strong>a随机密码生成</strong><br>
‪‬‪‬‪‬‪‬以整数17为随机数种子，获取用户输入整数N为长度，产生3个长度为N位的密码，密码的每位是一个数字。每个密码单独一行输出。产生密码采用random.randint()函数。</p>
<pre><code>import random
def genpwd(length): #输入长度3，生成3位数范围
    x = pow(10,length-1) #1
    y = pow(10,length)-1 #999
    return random.randint(x,y) # x &lt;= length &lt;= y
length = eval(input())
random.seed(17)
for i in range(3): #生成3个密码
    print(genpwd(length))
</code></pre>
<p><strong>b连续质数计算</strong><br>
获得用户输入数字N，计算并输出从N开始的5个质数，单行输出，质数间用逗号,分割。需要考虑用户输入的数字N可能是浮点数，应对输入取整数；最后一个输出后不用逗号。</p>
<pre><code>def prime(m):
    （temp=int(math.sqrt(m))
    for i in range(2,temp+1): ）#此方法可减少计算机作不必要晕眩。
    for i in range(2,m): #在2到m范围内运算，看是否有整除数
        if m%i == 0:
            return False
        else:
            return True
n = eval(input())
t = int(n)
if t &lt; n: #只要输入带小数的数，均取整后+1才能作质数判断
    t+=1
count = 5
while count&gt;0:
    if prime(t):
        if count &gt;1 :
            print(t,end=&quot;,&quot;)
        else:
            print(t)
        count-=1
    t+=1
</code></pre>
<p><strong>c任意累积</strong></p>
<pre><code>def cmul(n, *b): #*b为可变参数，是一个组合数据类型，包含1个或多个参数
    s = n
    for item in b:
        s*=item
    return s
print(eval(&quot;cmul({})&quot;.format(input())))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0303 | Al la bout book]]></title>
        <id>https://pythonangry.github.io/post/EuQroKpAd/</id>
        <link href="https://pythonangry.github.io/post/EuQroKpAd/">
        </link>
        <updated>2020-03-03T05:05:56.000Z</updated>
        <content type="html"><![CDATA[<p>行业报告：《2018-2019中国实体书店产业报告》<br>
http://www.chyxx.com/research/201712/597425.html</p>
<h4 id="一-图书馆机构">一、图书馆机构</h4>
<ol>
<li><a href="https://www.ifla.org/">IFLA</a></li>
<li><a href="http://www.ala.org/">ALA</a><br>
<a href="http://www.ala.org/pla/">PLA</a> 公共图书馆<br>
<a href="http://www.ala.org/aasl/">AASL</a> 学校图书馆</li>
<li><a href="https://www.cilip.org.uk/">CILIP</a></li>
<li><a href="https://www.oclc.org/en/home.html">OCLC</a></li>
</ol>
<h4 id="二-国家公共大学图书馆">二、国家/公共/大学图书馆</h4>
<ol>
<li>新加坡 <a href="https://www.nlb.gov.sg/">NPL</a></li>
<li>美国 <a href="https://www.loc.gov/">Library of congress</a></li>
<li>中国<a href="http://www.nlc.cn/">中国国家图书馆</a></li>
<li>香港<a href="https://sc.lcsd.gov.hk/TuniS/www.hkpl.gov.hk/tc/index.html">香港公共图书馆</a></li>
<li>台湾<a href="https://www.ncl.edu.tw/">国家图书馆</a><a href="https://319readingtw.fandom.com/zh/wiki/%E9%A6%96%E9%A1%B5">台湾图书馆列表</a></li>
<li>英国<a href="https://www.bl.uk/">The British Library</a></li>
<li>澳大利亚<a href="https://www.nla.gov.au/">National Library of Australia</a></li>
<li>纽约<a href="https://www.nypl.org/">New York Public Library</a></li>
<li><a href="http://www.gzlib.org.cn/">广州图书馆</a></li>
<li><a href="https://www.szlib.org.cn/">深圳图书馆</a></li>
<li><a href="https://www.nslib.cn/">南山图书馆</a></li>
</ol>
<h4 id="三-出版社">三、出版社</h4>
<ol>
<li><a href="https://thamesandhudson.com/">Thames&amp;hudson</a></li>
<li><a href="https://uk.phaidon.com/agenda/">Phaidon</a></li>
<li><a href="http://www.skira.net/">Skira</a></li>
<li><a href="https://www.taschen.com/">TASCHEN</a></li>
<li><a href="https://www.penguin.com/">Penguin</a></li>
<li><a href="https://www.azothbooks.com/">漫游者书店</a></li>
<li><a href="https://www.suncolor.com.tw/">三采网路书店</a></li>
<li><a href="http://www.spbooks.cn/">善本图书</a></li>
<li><a href="https://publishing.andrewsmcmeel.com/">Andrews Mcmeel</a><br>
TALENT, RECOGNIZED<br>
We're passionate about publishing authors with a distinct point of view. We offer an individualized, flexible approach to publishing success by respecting the author's vision as the primary source of inspiration at every stage of the editorial, marketing and distribution process.</li>
</ol>
<h4 id="四-书店">四、书店</h4>
<ol>
<li><a href="http://www.sisyphe.com.cn/index.html#">西西弗书店</a></li>
<li><a href="http://www.yanjiyou.com/col.jsp?id=106">言几又</a></li>
<li><a href="http://www.fangsuo.com/index/index.html">方所</a></li>
</ol>
<h4 id="五-作家主页">五、作家主页</h4>
<ol>
<li><a href="http://www.oliverjeffersworld.com/">Oliver Jeffers</a></li>
<li><a href="http://www.elishacooper.com/">Elisha Cooper</a></li>
<li><a href="https://www.chrishaughton.com/home">Chris Haughton</a></li>
<li><a href="http://mowillems.com/">Mo Willems</a></li>
</ol>
<h4 id="其他">其他</h4>
<p>在<a href="https://www.npr.org/">NPR</a>等媒体网站搜索library获取最新信息</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图书馆 | 信息素养与小工具小技巧]]></title>
        <id>https://pythonangry.github.io/post/QdMJ-rp8n/</id>
        <link href="https://pythonangry.github.io/post/QdMJ-rp8n/">
        </link>
        <updated>2020-03-02T12:41:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="part-one-信息素养基本内容">Part one 信息素养基本内容</h3>
<p>以下内容均出自<a href="https://www.icourse163.org/course/SICNU-1002031014">Mooc</a>《信息素养：效率提升与终身学习的新引擎》 周建芳</p>
<blockquote>
<h4 id="信息素养定义">信息素养定义</h4>
<p>基于信息解决问题的综合能力和基本素质</p>
</blockquote>
<blockquote>
<h4 id="六种基本能力">六种基本能力</h4>
<blockquote>
<ol>
<li>信息需求识别能力：知道有哪些信息，会找攻略</li>
<li>信息检索能力：专用SE，垂直SE，万不得已不用综合SE</li>
<li>信息获取能力</li>
<li>信息评价能力：对信息本身真伪优劣的评价，基于信息评价其他</li>
<li>信息管理能力：利用程序软件客户端管理信息，<em>Total commander</em></li>
<li>应用信息的能力</li>
</ol>
</blockquote>
</blockquote>
<p><strong>信息评价</strong>：通过多方查询减少<strong>信息不对称</strong></p>
<ul>
<li>医院医护人员资质 - 国家卫生和计划生育委员会</li>
<li>医药保健品 - 国家食品药品监督管理局</li>
<li>企业 - 国家企业信用公示系统，产权专利商标，中国庭审公开网等</li>
<li>个人 - 学历学籍，证书资质，职业资格，信用等</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://pythonangry.github.io/post-images/1583285298339.jpg" alt="" loading="lazy"></figure>
<blockquote>
<h4 id="三个基础">三个基础</h4>
<blockquote>
<ul>
<li>信息知识</li>
<li>信息伦理</li>
<li>信息意识</li>
</ul>
</blockquote>
</blockquote>
<hr>
<h4 id="part-two-小工具与小技巧">Part two 小工具与小技巧</h4>
<h5 id="1-解决信息需求的途径">1. 解决信息需求的途径</h5>
<ul>
<li>电商网站：获取商品种类信息</li>
<li><a href="https://www.wikihow.com/Main-Page">Wikihow</a></li>
<li><a href="https://magi.com/">MAg[i]</a>：基于机器学习的信息抽取和检索系统</li>
</ul>
<h5 id="2-利用垂直搜索获取专用信息">2. 利用垂直搜索获取专用信息</h5>
<ul>
<li>产品行业标准，专利：国家标准公开系统，中国专利公布公告网</li>
<li>找寻相似网站：<a href="https://www.similarsitesearch.com/">Similar site search</a></li>
</ul>
<h5 id="3-获取统计数据途径">3. 获取统计数据途径</h5>
<ul>
<li>
<p>国家统计局</p>
</li>
<li>
<p><a href="https://www.pewresearch.org/">Pew research center</a></p>
</li>
<li>
<p><a href="https://www.nielsen.com/cn/zh/">Nielsen</a></p>
</li>
<li>
<p>百度指数，阿里指数，微指数，微信指数，爱奇艺指数，导航App实时拥堵数据</p>
</li>
<li>
<p>英文用法数据 <a href="https://www.linggle.com/">Liggle10^12</a></p>
</li>
<li>
<p>超级课程表App</p>
<h5 id="删除网页脚本获取文字内容">删除网页脚本获取文字内容</h5>
<ol>
<li>查看网页代码</li>
<li>复制代码，删除文本之前的代码</li>
<li>将文件另存为文件名.html/htm, 文件类型选择所有文件</li>
<li>打开此网页文件，文本即可复制</li>
</ol>
</li>
</ul>
<h5 id="保存网页内图片">保存网页内图片</h5>
<p>Alt+printscreen可进行截图<br>
多图网页保存，利用右键保存所有网页文件即可</p>
<h5 id="网站视频下载">网站视频下载</h5>
<ol>
<li>利用源地址识别工具如<strong>硕鼠</strong>将网页识别，硕鼠会返回视频下载地址</li>
<li>利用浏览器缓存文件夹识别刚刚看过的视频文件</li>
</ol>
<h5 id="类型书搜索下载">类型书搜索下载</h5>
<p><a href="https://yabook.org/">雅书</a>:PDF电子书学习下载站<br>
<a href="https://etc.usf.edu/lit2go/">lit2go</a>:有声书</p>
<p>让别人提参考和信息服务要求，写明白想要怎样的报告？还是自己列一些报告呈现形式供人挑选。<br>
利用这个来提升自己？</p>
]]></content>
    </entry>
</feed>