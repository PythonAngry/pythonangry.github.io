<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pythonangry.github.io</id>
    <title>PythonAngry</title>
    <updated>2020-04-22T02:22:21.028Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pythonangry.github.io"/>
    <link rel="self" href="https://pythonangry.github.io/atom.xml"/>
    <logo>https://pythonangry.github.io/images/avatar.png</logo>
    <icon>https://pythonangry.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, PythonAngry</rights>
    <entry>
        <title type="html"><![CDATA[0413 | 又双叕学python（2）]]></title>
        <id>https://pythonangry.github.io/post/DjCAaxOU_/</id>
        <link href="https://pythonangry.github.io/post/DjCAaxOU_/">
        </link>
        <updated>2020-04-13T03:32:20.000Z</updated>
        <content type="html"><![CDATA[<h4 id="12基本统计值计算">12.基本统计值计算</h4>
<pre><code>def getNum():
    nums = []
    iNumStr = input(&quot;请输入数字（回车退出）：&quot;)
    while iNumStr !=&quot;&quot;:
        nums.append(eval(iNumStr))
        iNumStr = input(&quot;请输入数字（回车退出）：&quot;)
    return nums

def mean(numbers):
    s = 0.0
    for num in numbers:
        s = s + num
    return s / len(numbers)

def dev(numbers, mean):
    sdev = 0.0
    for num in numbers:
        sdev = sdev + (num - mean)**2
    return pow(sdev / (len(numbers)-1), 0.5) #方差公式

def median(numbers):
    sorted(numbers)
    size = len(numbers)
    if size % 2 == 0:
        med = ((numbers[size//2-1]) + numbers[size//2])/2 #从0号位开始取，[1,5]=取前不取后，取1，2，3，4。
    else:
        med = numbers[size//2]
    return med

n = getNum()
m = mean(n)
print('平均值:{},方差:{:.2},中位数:{}'.format(m,dev(n,m),median(n)))
</code></pre>
<h4 id="13哈姆雷特词频统计">13.哈姆雷特词频统计</h4>
<pre><code>def getText():
    txt = open('hamlet.txt','r').read()
    txt = txt.lower()
    for ch in '!&quot;$%&amp;()*+,-./;:&lt;&gt;=?@[\\]^_{|}~`':
        txt = txt.replace(ch, &quot; &quot;)
    return txt

hamletTxt = getText()
words = hamletTxt.split()
counts = {}
for word in words:
    counts[word] = counts.get(word,0) + 1
items = list(counts.items())
items.sort(key=lambda x:x[1], reverse=True)
for i in range(10):
    word, count = items[i]
    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word, count))
</code></pre>
<h4 id="14三国演义人物出场统计">14.三国演义人物出场统计</h4>
<pre><code>import jieba
txt = open('sanguo.txt','r',encoding=utf-8).read()
excludes = {'将军','却说','荆州','二人','不可','不能','如此','...'}
words = jieba.lcut(txt)
counts = {}
for word in words:
    if len(word) == 1:
        continue
    elif word == '诸葛亮' or word == '孔明曰':
        rword = '孔明'
    elif word == '关公' or word == '云长':
        rword = '关羽'
    elif word == '玄德' or word == '玄德曰':
        rword = '刘备'
    elif word == '孟德' or word == '丞相':
        rword = '曹操'
    elif word == '...' or word == '...':
        rword = '..'
    else:
        rword = word
    counts[word] = counts.get(word,0) + 1
for word in excludes:
    del counts[word]
items = list(counts.items())
items.sort(key=lambda x:x[1], reverse=True)
for i in range(10):
    word, count = items[i]
    print(&quot;{0:&lt;10}{1:&gt;5}&quot;.format(word, count))
</code></pre>
<h4 id="15自动轨迹绘制">15.自动轨迹绘制</h4>
<p><strong>基本思路</strong></p>
<ol>
<li>定义数据文件格式（接口）</li>
<li>编写程序，根据文件接口解析参数绘制图形</li>
<li>编制数据文件<br>
<strong>理解方法思维</strong></li>
</ol>
<ul>
<li>自动化思维：数据和功能分离，数据驱动自动运行</li>
<li>接口化设计：格式化设计接口，清晰明了</li>
<li>二维数据应用：应用维度组织数据</li>
</ul>
<pre><code>import turtle as t
t.title('自动轨迹绘制')
t.setup(800,600,0,0)
t.pencolor('red')
t.pensize(5)
# 数据读取
datals = []
f = open('data.txt') #打开数据文件
for line in f:
    line = line.replace('\n','') #将每一行的回车去除
    datals.append(list(map(eval,line.split(',')))) #map函数将eval方法运用到每一个元素当中
f.close() #正确及时关闭文件，若忘记，程序正确运行后也会关闭
# 自动绘制
for i in range(len(datals)): #此时，列表datals由一个个列表元素组成，即二维数据
    #数据接口形式如：300,1,144,0,1,0 分别为行进距离，转向判断（0左转，1右转），转向角度，及RGB三个通道颜色（0-1之间的浮点数）
    t.pencolor(datals[i][3],datals[i][4],datals[i][5])
    t.fd(datals[i][0])
    if datals[i][1]:
        t.right(datals[i][2])
    else:
        t.left(datals[i][2])
</code></pre>
<h4 id="16政府工作报告词云">16.政府工作报告词云</h4>
<pre><code>import jieba
import wordcloud
from imageio import imread
mask = imread('fivestar.png') #运用imread将词云形状进行设定，也可以不设定，默认长方形
f = open('f.txt','r',encoding='utf-8')
t = f.read()
f.close()
ls = jieba.lcut(t) #中文文本需要分词
txt = ' '.join(ls) #把分出来的中文词列表用空格连接形成长字符串
w = wordcloud.WordCloud(font_path = 'msyh.ttc', mask = mask\ #mask方法形成不规则词云
                        width = 1000, height = 700, background_color ='white', \)
w.generate(txt)
w.to_file('growordcloud.png')
</code></pre>
<h4 id="17第七周练习题">17.第七周练习题</h4>
<h5 id="acsv格式清洗与转换">a.CSV格式清洗与转换</h5>
<p>（1）按行进行倒序排列<br>
（2）每行数据倒序排列<br>
（3）使用分号（;）代替逗号（,）分割数据，无空格</p>
<pre><code>f = open('data.csv','r')
lines = f.readlines()
lines.reverse()

for line in lines:
    line = line.replace('\n','')
    line =line.replace(' ','')
    t = line.split(&quot;,&quot;)
    t.reverse()
    print(&quot;;&quot;.join(t))
</code></pre>
<h5 id="b文本的平均列数">b.文本的平均列数</h5>
<p>（1）有效行指包含至少一个字符的行，不计空行<br>
（2）每行的列数为其有效数<br>
（3）平均列数为有效行的列数平均值，采用四舍五入方式取整数进位</p>
<pre><code>f= open('latex.log','r')
bar = 0
chars = 0
for line in f.readlines():
    if not (len(line) == 1  and line[-1]=='\n') :
        bar +=1
        chars += len(line)-1

avg = round(chars/bar,0)
avg = int(avg)
print(avg)‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪
</code></pre>
<h5 id="c第七周选做习题">c.第七周选做习题</h5>
<p><img src="https://pythonangry.github.io/post-images/1586747620320.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748303359.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748612258.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748669253.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1586748723905.png" alt="" loading="lazy"></p>
<h4 id="18体育竞技分析">18.体育竞技分析</h4>
<ul>
<li>计算思维：抽象+自动化</li>
<li>模拟：抽象比赛过程+自动化执行N场比赛</li>
<li>当N越大，比赛结果分析越科学<br>
<strong>（1）自顶向下（设计）</strong></li>
<li>将一个总问题表达为若干小问题组成的形式</li>
<li>使用同样方法进一步分析小问题<br>
<strong>（2）自底向上（执行）</strong></li>
<li>分单元测试，逐步组装</li>
<li>按自顶向下相反的路径操作</li>
<li>直至系统各部分以组装的思路都经过测试和验证</li>
</ul>
<hr>
<p><strong>程序总体框架及步骤</strong></p>
<ul>
<li>步骤1：打印程序介绍信息 ——printInfo()</li>
<li>步骤2：获得程序运行参数：proA，proB，n ——getInputs()</li>
<li>步骤3：利用球员A和B的能力值，模拟n局比赛 ——simNGames()</li>
<li>步骤4：输出球员A和B获胜比赛的场次及概率 ——printSummary()</li>
</ul>
<pre><code>from random import random

def main():
    printIntro()
    proA, proB, n = getInputs()
    winsA, winsB = simNGames(n, proA, proB)
    printSummary(winsA, winsB)

def printIntro():
    print('this game is between A and B')
    print('the value of A and B are needed')

def getInputs():
    a = eval(input('please input value A:'))
    b = eval(input('please input value B:'))
    n = eval(input('game would be run:'))
    return a, b, n

def printSummary(winsA, winsB):
    n = winsA + winsB
    print('game run {}'.format(n))
    print('A wins {}, as{:0.1%}'.format(winsA, winsA/n))
    print('B wins {}, as{:0.1%}'.format(winsB, winsB/n))

def simNGames(n, proA, proB):
    winsA, winsB = 0, 0
    for i in range(n):
        scoreA, scoreB = simOneGame(proA, proB) #模拟一局比赛
        if scoreA &gt; scoreB:
            winsA += 1
        else:
            winsB += 1
    return winsA, winsB

def simOneGame(proA, proB):
    scoreA, scoreB = 0, 0
    serving = 'A'
    while not gameOver(scoreA, scoreB):
        if serving == 'A':
            if random() &lt; proA:
                scoreA +=1
            else:
                serving ='B'
        else:
            if random() &lt; proB:
                scoreB +=1
            else:
                serving = 'A'
    return scoreA, scoreB

def gameOver(a,b):
    return a==15 or b==15

main()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0404 | 统计学]]></title>
        <id>https://pythonangry.github.io/post/HoJsDOlnB/</id>
        <link href="https://pythonangry.github.io/post/HoJsDOlnB/">
        </link>
        <updated>2020-04-04T01:33:11.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://pythonangry.github.io/post-images/1585964012087.png" alt="" loading="lazy"><br>
标准差的自由值<br>
<img src="https://pythonangry.github.io/post-images/1586004274765.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1585964025232.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0403 | 数据结构与算法]]></title>
        <id>https://pythonangry.github.io/post/LFgTZAtp8/</id>
        <link href="https://pythonangry.github.io/post/LFgTZAtp8/">
        </link>
        <updated>2020-04-03T02:22:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1算法分析">1算法分析</h3>
<figure data-type="image" tabindex="1"><img src="https://pythonangry.github.io/post-images/1585966998751.png" alt="" loading="lazy"></figure>
<h4 id="11变位词判断问题">1.1变位词判断问题</h4>
<p><strong>1.1.1 逐字检查 O(n^2)</strong></p>
<ul>
<li>两重循环，外层遍历s1每个字符，将内层循环执行n次</li>
<li>内层循环在s2查找字符，每个字符对比次数从1-N，各不相同</li>
</ul>
<pre><code>def anagramSolution1(s1,s2):
    alist = list(s2) #复制s2到列表
    pos1 = 0
    stillOK = True
    while pos1 &lt; len(s1) and stillOK:
        pos2 = 0
        found = False
        while pos2 &lt; len(alist) and not found: #循环s1每一个字符
            if s1[pos1] == alist[pos2]: #与s2逐个对比
                found = True
            else:
                pos2 = pos2 +1
        if found:
            alist[pos2] = None #找到，打勾设为空
        else:
            stillOK = False #没找到，失败
        pos1 = pos1 +1
    return stillOK

print(anagramSolution1('abcd','dcba'))
</code></pre>
<p><strong>1.1.2 排序比较 O(nlogn)</strong></p>
<ul>
<li>本算法主导步骤是排序步骤</li>
</ul>
<pre><code>def anagramSolution2(s1,s2):
    alist1 = list(s1)
    alist2 = list(s2)
    
    alist1.sort()
    alist2.sort()
    pos = 0
    matches = True
    while pos &lt; len(s1) and matches:
        if alist1[pos] == alist2[pos]:
                pos = pos +1
        else:
            matches = False
    return matches

print(anagramSolution2('abcde','edcba'))
</code></pre>
<p><strong>1.1.3 暴力法 O(n!)</strong></p>
<ul>
<li>穷尽所有可能的组合</li>
<li>将s1出现的字符进行全排列，查看s2是否出现在全排列列表中</li>
</ul>
<p><strong>1.1.4 计数比较 O(n)</strong></p>
<ul>
<li>3个非嵌套循环迭代</li>
<li>依赖26计数器列表，储存空间用量最多，问题解法需要取舍权衡时间与空间</li>
</ul>
<pre><code>def anagramSolution4(s1,s2):
    c1 = [0] * 26 #26个0的列表
    c2 = [0] * 26
    for i in range(len(s1)): #分别计算
        pos = ord(s1[i]) - ord('a') #ord('a')=97 b98...
        c1[pos] = c1[pos] +1
    for i in range(len(s2)):
        pos = ord(s1[i]) - ord('a')
        c2[pos] = c2[pos] +1
    j = 0
    stillOK = True
    while j &lt; 26 and stillOK: #计数器比较
        if c1[j] == c2[j]:
            j = j + 1
        else:
            stillOK = False
    return stillOK

print(anagramSolution4('apple','pleap'))
</code></pre>
<h3 id="2python数据类型性能">2Python数据类型性能</h3>
<p>总方案：让最常用的操作性能最好<br>
官方算法复杂度网站:<a href="https://wiki.python.org/moin/TimeComplexity"></a></p>
<h3 id="3线性结构">3线性结构</h3>
<ul>
<li>有序，除第一个与最后一个，中间数据有唯一的前驱和后继，新增数据只会加到原有某数据之前或之后</li>
</ul>
<h4 id="31栈">3.1栈</h4>
<ul>
<li>数据加入和移除都仅发生在同一端</li>
<li>距离栈底越近的数据项，留在栈中的时间越长</li>
<li>后进先出LIFO</li>
<li>特性：反转次序[浏览器后退][文档撤销]</li>
<li>通常选用list末端(index = 1-)作为栈顶<br>
<strong>3.1.1 括号匹配</strong><br>
a.简单括号匹配</li>
</ul>
<pre><code>from pythonds import Stack

def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index &lt; len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol == '(':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                s.pop()

        index = index + 1

    if balanced and s.isEmpty():
        return True
    else:
        return False

print(parChecker('((()))'))
print(parChecker('(()'))
</code></pre>
<p>b.通用括号匹配</p>
<pre><code>from pythonds import Stack

def parChecker(symbolString):
    s = Stack()
    balanced = True
    index = 0
    while index &lt; len(symbolString) and balanced:
        symbol = symbolString[index]
        if symbol in '([{':
            s.push(symbol)
        else:
            if s.isEmpty():
                balanced = False
            else:
                top = s.pop()
                if not matches(top,symbol):
                    balanced = False
        index = index + 1
    if balanced and s.isEmpty():
        return True
    else:
        return False

def matches(open,close):
    opens = '([{'
    closers = ')]}'
    return opens.index(open) == closers.index(close) #查询值的位置查看是否相等

print(parChecker('({}{[}})'))
print(parChecker('{[()]()}'))
</code></pre>
<p><strong>3.1.2进制转换</strong><br>
a.十进制转换为二进制<br>
转换过程中余数从在栈中排列从上端到下端看为从低到高，<br>
出栈时则需要从高到低排列，正好符合栈的特性</p>
<pre><code>from pythonds import Stack

def divideBy2(decNumber):
    remstack = Stack()

    while decNumber &gt; 0:
        rem = decNumber % 2 #求余数
        remstack.push(rem)
        decNumber = decNumber // 2 #整除数

    binString = ''
    while not remstack.isEmpty():
        binString = binString + str(remstack.pop())

    return binString

print(divideBy2(42))
</code></pre>
<p>b.十进制转换为十六以下任意进制</p>
<pre><code>from pythonds import Stack

def baseConverter(decNumber,base):
    digits = '0123456789ABCDEF'

    remstack = Stack()

    while decNumber &gt; 0:
        rem = decNumber % base #求余数
        remstack.push(rem)
        decNumber = decNumber // base #整除数

    newString = ''
    while not remstack.isEmpty():
        newString = newString + digits[remstack.pop()] #索引位置返回值

    return newString

print(baseConverter(25,2))
print(baseConverter(19920,16))
</code></pre>
<p><strong>3.1.3表达式转换</strong></p>
<ul>
<li>全括号表达式：把运算符移到右或左括号位置替代即可变为后缀或前缀形式</li>
<li>中缀、前缀和后缀表达式<br>
a.中缀表达式转换为后缀表达式</li>
</ul>
<pre><code>from pythonds import Stack

def infixToPostfix(infixexpr):
    prec = {}
    prec['*'] = 3 #记录操作符优先级
    prec['/'] = 3
    prec['+'] = 2
    prec['-'] = 2
    prec['('] = 1
    opStack = Stack()
    postfixList = []
    tokenList = infixexpr.split() #解析表达式到单词列表

    for token in tokenList:
        if token in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' or token in '0123456789': #操作数
            postfixList.append(token)
        elif token == '(':
            opStack.push(token)
        elif token == ')':
            toptoken = opStack.pop()
            while toptoken != '(':
                postfixList.append(toptoken)
                toptoken = opStack.pop()
        else:                                                #操作符
            while (not opStack.isEmpty()) and \
                    (prec[opStack.peek()] &gt;= prec[token]):
                        postfixList.append(opStack.pop())
            opStack.push(token)

    while not opStack.isEmpty():
        postfixList.append(opStack.pop())    #操作符
    return ' '.join(postfixList)   #合成后缀表达式字符串
</code></pre>
<p>b.后缀表达式求值</p>
<pre><code>from pythonds import Stack

def postfixEval(postfixExpr):
    operandStack = Stack()
    tokenList = postfixExpr.split()

    for token in tokenList:
        if token in  '0123456789': #操作数
            operandStack.push(int(token))
        else:
            operand2 = operandStack.pop()
            operand1 = operandStack.pop()
            result = doMath(token, operand1, operand2)
            operandStack.push(result)
    return operandStack.pop()

def doMath(op, op1, op2):
    if op == '*':
        return op1 * op2
    elif op == '/':
        return op1 / op2
    elif op == '+':
        return op1 + op2
    else:
        return op1 - op2
</code></pre>
<p><strong>3.1.4 一维消消乐</strong></p>
<pre><code>from pythonds import Stack

def remover(symbolString):
    s = Stack()
    index = 0
    str = []
    while index &lt; len(symbolString):
        symbol = symbolString[index]
        if s.isEmpty():
            s.push(symbol)
        elif not s.isEmpty():
            if symbol == s.peek():
                s.pop()
            else:
                s.push(symbol)
        index +=1
    if s.isEmpty():
        str = ''.join(&quot;None&quot;)
        return str
    else:
        while not s.isEmpty():
            str.append(s.pop())
        return ''.join(str[::-1])

print(remover('abba'))
print(remover('abbacd'))
</code></pre>
<ul>
<li>可以直接join stack中的元素（''.join(s.items)），不需要pop出来倒叙，stack本质上的定义仍为一个列表</li>
</ul>
<pre><code>from pythonds import Stack

s = Stack()
def remover(symbolString):
    index = 0
    while index &lt; len(symbolString):
        symbol = symbolString[index]
        if s.isEmpty():
            s.push(symbol)
        elif not s.isEmpty():
            if symbol == s.peek():
                s.pop()
            else:
                s.push(symbol)
        index +=1
    return ''.join(s.items)

if not s.isEmpty:
    print(s)
else:
    print('None',end='')

print(remover('abba'))
print(remover('accbcf'))
</code></pre>
<h4 id="32-队列">3.2 队列</h4>
<p><strong>3.2.1 热土豆</strong></p>
<pre><code>def hotpotato(namelist, num):
    simqueue = Queue()
    for name in namelist:
        simqueue.enqueue(name)

    while simqueue.size() &gt; 1:
        for i in range(num):
            simqueue.enqueue(simqueue.dequeue()) #一次传递

        simqueue.dequeue()

    return simqueue.dequeue()

print(hotpotato(['bill','david','susan','jane','kent','bard'],7))
</code></pre>
<p><strong>3.2.2 打印任务</strong><br>
复习！自己重新输出思路！</p>
<p><strong>3.2.1 回文词</strong></p>
<pre><code>from pythonds import Deque #双端队列

def palchecker(aString):
    chardeque = Deque()

    for ch in aString:
        chardeque.addRear(ch) # asdf → rear · fdsa · front

    stillEqual = True

    while chardeque.size() &gt; 1 and stillEqual:
        first = chardeque.removeFront()
        last = chardeque.removeRear()
        if first != last:
            stillEqual = False

    return stillEqual

print(palchecker('sfderrd'))
print(palchecker('radar'))
</code></pre>
<h4 id="33链表">3.3链表</h4>
<p><strong>3.3.1 无序表</strong></p>
<pre><code>class Node:
    def __init__(self,initdata):
        self.data = initdata
        self.next = None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self,newdata):
        self.data = newdata

    def setNext(self,newnext):
        self.next = newnext

class UnorderList:

    def __init__(self):
        self.head = None

def add(self,item): #add方法实现
    temp = Node(item)
    temp.setNext(self.head) #链接次序不能反
    self.head = temp

def size(self): #size的实现
    current = self.head
    count = 0
    while current != None:
        count = count + 1
        current = current.getNext()

    return count

def search(self,item): #seatch的实现
    current = self.head
    found = False
    while current != None and not found:
        if current.getData() == item:
            fount = True
        else:
            current = current.getNext()

    return found

def remove(self,item): #remove（item）方法
    current = self.head
    previous = None
    found = False
    while not found:
        if current.getData() == item:
            found = True
        else:
            previous = current
            current = current.getNext()

    if previous == None: #第一个就找到，要remove
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
</code></pre>
<p><strong>3.3.2 有序表</strong></p>
<pre><code>def add(self,item): #找到第一个比他大的就可以加入
    current = self.head
    previous = None
    stop = False
    while current != None and not stop:
        if current.getData() &gt; item: #发现插入位置
            stop = True
        else:
            previous = current
            current = current.getNext

    temp = Node(item)
    if previous == None: #插在表头
        temp.setNext(self.head)
        self.head = temp
    else:                  #插在表中
        temp.setNext(current)
        previous.setNext(temp)
</code></pre>
<h3 id="4-递归">4 递归</h3>
<p><strong>递归三定律</strong></p>
<ul>
<li>基本结束条件，解决最小规模问题</li>
<li>缩小规模，向基本结束条件演进</li>
<li>调用自身来解决已缩小规模的相同问题</li>
</ul>
<h4 id="41-递归的应用">4.1 递归的应用</h4>
<p><strong>4.1.1 任意进制转换</strong></p>
<ul>
<li>基本结束条件：余数小于进制基base</li>
<li>更小规模问题：整数商</li>
</ul>
<pre><code>def toStr(n, base):
    converString = '0123456789ABCDEF'
    if n &lt; base:
        return converString[n] #最小规模
    else:
        return toStr(n//base, base) + converString[n%base] #调用自身
print(toStr(1453, 16))
</code></pre>
<p><strong>4.1.2 海龟作图</strong><br>
a. 螺旋</p>
<pre><code>import turtle

t = turtle.Turtle()

def drawSpiral(t, lineLen):
    if lineLen &gt; 0: #最小规模，0直接退出
        t.forward(lineLen)
        t.right(90)
        drawSpiral(t, lineLen - 5) #减少规模调用自身，边长减5

drawSpiral(t, 100)

turtle.done()
</code></pre>
<p>b. 分形树</p>
<pre><code>import turtle

def tree(branch_len):
    if branch_len &gt; 5: #树干太短不画，基本结束条件
        t.forward(branch_len) #画树干
        t.right(20) #右倾斜20度
        tree(branch_len - 15) #递归调用，画右边小树，树干减15
        t.left(40) #向左回40度
        tree(branch_len - 15) #递归调用，画左边小树，树干减15
        t.right(20) #向左回20度，即回正
        t.backward(branch_len) #海龟退回原位置

t = turtle.Turtle()
t.left(90)
t.penup()
t.backward(100)
t.pendown()
t.pencolor('green')
t.pensize(2)
tree(100) #画树干长度75的二叉树
t.hideturtle()
turtle.done()
</code></pre>
<p>c.谢尔宾斯基Sierpinski三角形</p>
<pre><code>import turtle

def sierpinski(degree, points):
    colormap = ['blue','red','green','white','yellow','orange','gray','pink']
    drawTriangle(points, colormap[degree]) #等边三角形
    if degree &gt;  0: #基本结束条件
        sierpinski(degree - 1,
                   {'left': points['left'],
                    'top':getMid(points['left'], points['top']), #减小规模：getMid边长减半，调用自身，左上右次序
                    'right':getMid(points['left'], points['right'])})
        sierpinski(degree - 1,
                   {'left': getMid(points['left'], points['top']),
                    'top': points['top'],
                    'right': getMid(points['top'], points['right'])})
        sierpinski(degree - 1,
                   {'left': getMid(points['left'], points['right']),
                    'top': getMid(points['top'], points['right']),
                    'right': points['right']})

def drawTriangle(points, color): #绘制等边三角形
    t.fillcolor(color)
    t.penup()
    t.goto(points['top'])
    t.pendown()
    t.begin_fill()
    t.goto(points['left'])
    t.goto(points['right'])
    t.goto(points['top'])
    t.end_fill()

def getMid(p1, p2): #取两个点的中点
    return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2 )

t = turtle.Turtle()

points = {'left':(-200, -100), #外轮廓三个顶点
          'top':(0, 200),
          'right':(200, -100)}
sierpinski(7, points) #7阶Sierpinski triangle
</code></pre>
<p>d.汉诺塔</p>
<ul>
<li>将最上层N-1个盘片从开始柱，经由目标柱，移动到中间柱</li>
<li>将第N个（最大的）盘片，从开始柱，移动到目标柱</li>
<li>将放在中间柱的N-1个盘片，经由开始柱，移动到目标柱</li>
</ul>
<pre><code>def moveTower(height, fromPole, withPole, toPole):
    if height &gt;= 1:
        moveTower(height - 1, fromPole, toPole, withPole)
        moveDisk(height, fromPole, toPole)
        moveTower(height - 1, withPole, fromPole, toPole)

def moveDisk(disk, fromPole, toPole):
    print(f'Moving disk[{disk}] from {fromPole} to {toPole}')

moveTower(3, '#1', '#2', '#3')
</code></pre>
<p>e.探索迷宫（表示投降）</p>
<h4 id="42优化递归策略">4.2优化递归策略</h4>
<p><strong>4.2.1 分治策略</strong></p>
<ul>
<li>解决问题的典型策略：分而治之</li>
</ul>
<p><strong>4.2.2 贪心策略</strong></p>
<ul>
<li>每次选择尽量大的部分一次解决<br>
a.找零兑换递归解法</li>
</ul>
<pre><code>def recMC(coinValueList, change):
    minCoins = change
    if change in coinValueList:
        return 1 #最小规模，直接返回
    else:
        for i in [c for c in coinValueList if c &lt;= change]:
            numCoins = 1 + recMC(coinValueList, change-i) #调用自身，减少规模：每次减去一种硬币面值，挑选最小数量
            if numCoins &lt; minCoins:
                minCoins = numCoins
    return minCoins

print(recMC([1,5,10,25], 63))
</code></pre>
<p>a`.找零兑换贪心解法</p>
<ul>
<li>求优化问题的一类算法</li>
<li>遍历备选元素</li>
<li>贪心策略确定选择一个元素<br>
B站<a href="https://www.bilibili.com/video/BV18Q4y1K7px?from=search&amp;seid=11522479327303874531">Ch8.1_贪心算法（硬币找零）_算法设计与分析Python</a></li>
</ul>
<pre><code>def getMinCoins(change):
    coins = [1, 5, 10 ,25]
    solution = []

    s_coins = sorted(coins, reverse=True)
    for c in s_coins:
        num_coin = int (change/c)
        solution +=[c, ]*num_coin

        change = change - c*num_coin
        if change &lt;= 0:
            break

    return solution

print(getMinCoins(63))
</code></pre>
<p><strong>4.2.3 动态规划</strong><br>
B站<a href="https://www.bilibili.com/video/BV18x411V7fm?from=search&amp;seid=5220760526841036340">动态规划 (第1讲)</a>;<a href="https://www.bilibili.com/video/BV12W411v7rd/?spm_id_from=333.788.videocard.0">动态规划 (第2讲)</a></p>
<ul>
<li>选与不选<br>
a.选择不相邻数字使和最大</li>
<li>递归分析<br>
<img src="https://pythonangry.github.io/post-images/1587521626140.jpg" alt="" loading="lazy"></li>
<li>递归解法<br>
<img src="https://pythonangry.github.io/post-images/1587521690387.jpg" alt="" loading="lazy"></li>
<li>动态规划<br>
<img src="https://pythonangry.github.io/post-images/1587521703716.jpg" alt="" loading="lazy"></li>
</ul>
<p>b.选择数组元素，和等于给定数字</p>
<ul>
<li>递归分析<br>
<img src="https://pythonangry.github.io/post-images/1587521842847.jpg" alt="" loading="lazy"></li>
<li>递归解法<br>
<img src="https://pythonangry.github.io/post-images/1587521853538.jpg" alt="" loading="lazy"></li>
<li>动态规划<br>
<img src="https://pythonangry.github.io/post-images/1587521908802.jpg" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1587521920417.jpg" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1587522064726.jpg" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0329 | Python组合数据类型比较]]></title>
        <id>https://pythonangry.github.io/post/MsFpeHMq-/</id>
        <link href="https://pythonangry.github.io/post/MsFpeHMq-/">
        </link>
        <updated>2020-03-29T07:48:14.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://pythonangry.github.io/post-images/1585468119942.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1585468128764.png" alt="" loading="lazy"><br>
<img src="https://pythonangry.github.io/post-images/1585468135760.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0325 | 职业素养]]></title>
        <id>https://pythonangry.github.io/post/4MzSOvVHu/</id>
        <link href="https://pythonangry.github.io/post/4MzSOvVHu/">
        </link>
        <updated>2020-03-25T02:38:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="管理">管理</h3>
<p>缓和情绪——冷静期——私下了解——给予表达机会</p>
<h3 id="回话到点子上">回话：到点子上</h3>
<p>厉害就是跟别人的不同之处<br>
差别的说明=A是**，B是##<br>
传达（结论）=从主干到枝叶<br>
不靠形容词，用数字说话<br>
很像=共通点+相异点<br>
变化=之前+之后<br>
必要性=‘没有’会产生困扰<br>
可信度=‘何时何地何人何事’等特质<br>
意见=提案，不畏反对的提案<br>
绝对=能做到的理由+做不到的补救<br>
表达可惜及失望=八成优点+两成缺点<br>
消极的理由=别的也可以<br>
积极的理由=别的就不行<br>
指出优缺点，事情才会改善<br>
很难说=优点一半+缺点一半<br>
方针=判断不要做的事=要做的事+不要做的事<br>
分情况=若是甲就…+若是乙就…<br>
自我介绍=与他人的不同+给对方的好处<br>
很适合你=商品的特征X对方的需求<br>
总结要用肯定句，别用否定句<br>
什么意思=讲重点/讲别人听得懂的话/请补上理论跳跃的空缺<br>
为什么=过去的原因+未来的目的<br>
根据=理论的妥当性优先于个人的意见<br>
原因分析=现在的状况，而非过去的原因/架构，而非心得<br>
解决方案=大体方针+具体细节/与问题点不互相矛盾<br>
没有交集→问对方怎样才能理解</p>
<h3 id="服务提点">服务提点</h3>
<ul>
<li>面对顾客宣扬道理，并且表达这是规定，只会惹怒对方，这种情况不能劈头就要求顾客按规定做，而是<strong>请问在这方面有什么需要帮忙的。</strong></li>
<li>想劝说跟你意见相左的人，最好不要直接提出与对方不同的意见，而是先问清楚对方基于什么理由，或者事情的原委，才得出那样的结论。</li>
<li>接纳客人的怒气，而不是归咎于人。面对一群旅行团和一位神经紧绷商务人士，双方的愉快程度不一，此时服务人员必须公正，不能站边（面对投诉方，<strong>我去了解一下情况</strong>，面对被投诉方<strong>请问有什么需要帮忙？是否能请您稍微考虑一下其他顾客（委婉）？</strong>），只支持某方意见。因为舒适与否会随着个人的价值观而异，但感觉不快却是共同的。声音嘈杂或环境脏乱，人会对此类负面感觉产生不快。提供服务的一方应当致力于迅速消除令客人感到不快的因素。</li>
<li>各位看起来非常开心……由于已经有点大声了……<strong>降低音量提醒对方</strong>，这点非常重要，如果声音太大传出去，会让人觉得被羞辱了。</li>
<li>问题解决后，询问有没有其他让顾客在意的地方呢？让您感到不愉快，<strong>非常抱歉，今后我们会尽全力改善（需要确实有改善）</strong></li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0320 | 野中郁次郎 - 知识创新]]></title>
        <id>https://pythonangry.github.io/post/0doq3JXF7/</id>
        <link href="https://pythonangry.github.io/post/0doq3JXF7/">
        </link>
        <updated>2020-03-20T03:11:58.000Z</updated>
        <content type="html"><![CDATA[<h4 id="隐性知识显性化">隐性知识显性化</h4>
<ol>
<li>要表达难以表达的事情，更依赖于比喻性语言和象征性手法</li>
<li>要传播知识，个人的知识必须与他人分享 #熟手技工</li>
<li>新知识往往诞生于模糊和<strong>冗余</strong>之中 #下达模糊指令，同一部门不同小组研究同一问题</li>
</ol>
<h4 id="知识转化的四种模式">知识转化的四种模式</h4>
<ul>
<li>社会化： 从隐性知识到隐性知识：徒弟模仿学习师傅 —— 共情知识</li>
<li>外显化： 从隐性知识到显性知识：书写，创造概念，演绎和归纳；依次使用比喻类比和模型 —— 概念性知识<br>
<img src="https://pythonangry.github.io/post-images/1584676264915.png" alt="" loading="lazy"></li>
<li>组合化： 从显性知识到显性知识：重新配置现有信息，产生新的知识 —— 系统性知识</li>
<li>内隐化： 从显性知识到隐性知识：做中学 —— 操作性知识<br>
<img src="https://pythonangry.github.io/post-images/1584680396602.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[0313 | 又双叕学python（1）]]></title>
        <id>https://pythonangry.github.io/post/1j3QsQSxV/</id>
        <link href="https://pythonangry.github.io/post/1j3QsQSxV/">
        </link>
        <updated>2020-03-13T09:23:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="需求解决">需求解决</h3>
<ol>
<li>实现多个同类网页同时搜索同一关键字</li>
<li>实现多行书籍ISBN导入，连续在商查网页搜索柜位，并返回相应结果至对应ISBN行柜位 *已解决4.17</li>
</ol>
<h3 id="学习工具">学习工具</h3>
<h4 id="相关网站">相关网站</h4>
<ul>
<li>Python社区：http://pypi.org/</li>
</ul>
<h4 id="算法练习">算法练习</h4>
<ul>
<li>https://leetcode-cn.com/</li>
</ul>
<h4 id="dir-help">dir(); help()</h4>
<ol>
<li>爬虫庫</li>
</ol>
<ul>
<li><a href="http://www.python-requests.org/">requests庫</a></li>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc">BeautifulSoup庫</a>：一个可以从HTML或XML文件中提取数据的Python庫</li>
<li><a href="https://docs.python.org/3.5/library/re.html">re正则表达式</a>：进行各类正则表达式处理</li>
<li><strong>爬虫协议:</strong> 网页地址/robots.txt #爬虫需留意不犯法</li>
</ul>
<ol start="2">
<li><a href="http://regex101.com">正则表达式验证网</a></li>
</ol>
<ul>
<li>500.2434: \d{1,}.\d{1,} #1到无穷数字, <strong>.</strong> 匹配 <strong>.</strong>,\d用[0-9]亦可</li>
<li>Test Sentence: [a-zA-z]{1,}</li>
<li>198.3.43.2:(?:\d{1,3}.){3} #**?😗*不捕获最后一个匹配</li>
</ul>
<p><strong>函数式编程</strong>：map()<br>
<strong>一一对应生成字典</strong>：zip()</p>
<h3 id="用python处理数据">用python处理数据</h3>
<h4 id="1清洗咖啡列表">1.清洗咖啡列表</h4>
<pre><code>def cleanList(lst):
    cleanedList = []
    for item in lst:
        for c in item:
            if c.isalpha() != True:
                item = item.replace(c,'')
        cleanedList.append(item)
    return cleanedList

coffeeList = ['32Latte','+Americano30','/34Cappuccino','Mocha35']
cleanedList = cleanList(coffeeList)
for k,v in zip(range(1,len(cleanedList)+1),cleanedList):
    print(k,v)
</code></pre>
<hr>
<h3 id="python爬虫">python爬虫</h3>
<h4 id="1-爬豆瓣短评">1. 爬豆瓣短评</h4>
<pre><code>import requests
from bs4 import BeautifulSoup
headers={'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'}
#加headers反反爬，在浏览器打上about://virsion查询，修改前无返回结果，于是print（r）
获得[418]：The HTTP 418 I’m a teapot client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference to Hyper Text Coffee Pot Control Protocol which was an April Fools’ joke in 1998.
r = requests.get('https://book.douban.com/subject/1084336/comments/',headers=headers)
soup = BeautifulSoup(r.text,'lxml') #将之前get到的对象r.text作为一个参数传入bs函数，获得一个bs对象soup
pattern = soup.find_all('span','short') #通过findall方法寻找评论所在的行，这个方法会返回一个列表。源代码中评论行的标签为span，属性为short。
for item in pattern: #遍历列表中的每一个项
    print(item.string)
</code></pre>
<h4 id="2爬豆瓣评分显然没爬到">2.爬豆瓣评分（显然没爬到）</h4>
<pre><code>import requests
from bs4 import BeautifulSoup
import re
headers={'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36'}
r = requests.get('https://book.douban.com/subject/1084336/comments/',headers=headers)
soup = BeautifulSoup(r.text,'lxml') 
pattern = soup.find_all('span','short') 
for item in pattern: 
    print(item.string)
pattern_s = re.compile('&lt;span class = “user-stars allstar(.*?) rating&gt;”') #用compile把字符串编译为pattern实例,.*?利用正则表达式获取字符串当中的评分内容
p = re.findall(pattern_s, r.text) #结果返回列表P
s=0
for star in p:
    s+=int(star)
print(s)

</code></pre>
<h4 id="3-动态网页爬取">3. 动态网页爬取</h4>
<p>使用<strong>开发者工具</strong></p>
<hr>
<h3 id="2019年9月第一次尝试学习de笔记">2019年9月第一次尝试学习de笔记</h3>
<pre><code>类
对象
属性
方法

print(a // b)  #除完取整
print(a % b)   #余数
print(a ** b)  #a的b次方

# %d 整数
# %f 带小数

# int()：将一个数值或字符串转换成整数，可以指定进制。
# float()：将一个字符串转换成浮点数。
# str()：将指定的对象转换成字符串形式，可以指定编码。
# chr()：将整数转换成该编码对应的字符串（一个字符）。
# ord()：将字符串（一个字符）转换成对应的编码（整数）。

# print ('%.1f' % (c)) #将c保留1位小数

# getpass 模块
# random模块的randint(随机数都应是int整数)函数生成指定范围的随机数
# 如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用for-in循环

# i=1
# j=0
# num = int(input())
# while i &lt;= num-1 :
#     print (i)
#     i = i + j
#     j = i + j

# def fib(n):
#     a, b = 0, 1
#     for _ in range(n):
#         a, b = b, a + b
#         yield a

# Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索

# def main():
#     # Todo: Add your code here
#     pass
#
#
# if __name__ == '__main__':
#     main()
</code></pre>
<hr>
<h3 id="中国mooc北京理工大学python语言程序设计">中国MOOC北京理工大学Python语言程序设计</h3>
<h4 id="知识点摘录">知识点摘录</h4>
<ul>
<li>evla可以去掉字符串或字符串变量的引号</li>
<li>print(&quot;fff:&quot;,i)  #逗号有形成空格的作用 = fff: i</li>
<li>range(N)产生0到N-1个数；(M,N)产生M到N-1个数</li>
<li>整数→浮点数→复数，123+4.0=127.0（数值的范围扩大为浮点数）</li>
<li>槽{}，只在字符串中有用</li>
<li>利用随机数种子生成“确定”的随机数，以便采用随机数的程序能够重演</li>
<li>紧耦合，松耦合 ：函数内紧耦合，函数间松耦合，紧耦合代码复用较为困难，一改全改</li>
</ul>
<h4 id="1温度转换">1.温度转换</h4>
<pre><code>TempStr = input()
if TempStr[-1] in ['F', 'f']:
     C = (eval(TempStr[0:-1]) - 32)/1.8
     print(&quot;{:.2f}C&quot;.format(C))
elif TempStr[-1] in ['C', 'c']:
     F = 1.8*eval(TempStr[0:-1]) + 32
     print(&quot;{:.2f}F&quot;.format(F))
else:
     print(&quot;输入格式错误&quot;)
</code></pre>
<h4 id="2货币转换">2.货币转换</h4>
<pre><code>money = input()
if money[0] in ['R']:  #记得加:
     USD = eval(money[3:])/6.78
     print(&quot;USD{:.2f}&quot;.format(USD))  #记得加引号
elif money[0] in ['U']:
     RMB = eval(money[3:])*6.78
     print(&quot;RMB{:.2f}&quot;.format(RMB))
</code></pre>
<h4 id="3数字一一对应替换">3.数字一一对应替换</h4>
<pre><code>table = ''.maketrans(&quot;abcdefghij&quot;,&quot;1234567890&quot;)  # 创建映射表，注意字符串的长度要一致，达到一一对应的目的
str = &quot;hello world! i love python&quot;
str.translate(table)  # 按照关系表将sting中的字符逐个进行替换
</code></pre>
<h4 id="4turtle可恶的蟒蛇">4.Turtle:可恶的蟒蛇</h4>
<pre><code>import turtle as t
t.setup(650,350,200,200)  #setup()设置窗体大小及位置。宽，高，x，y。
t.penup()  #t.pu()
t.fd(-250)  #海龟的正前方向运行t.fd(d)
t.pendown()  #t.pd()
t.pensize(25)  #t.width()
t.pencolor('purple')  #purple要小写
t.seth(-40)  #改变海龟行进方向，不作画，逆时针40度
for i in range(4):
    t.circle(40,80)  #以海龟当前某点为圆心进行曲线运行turtle.circle(r,angle), r为半径，圆心在turtle左方r距离处，绘制弧度为angle，90则绘制90度弧线
    t.circle(-40,80)
t.circle(40,80/2)
t.fd(40)
t.circle(16,180)
t.fd(40*2/3)
t.done()  #加了此行代码程序不会自动退出
</code></pre>
<h4 id="turtle知识点">turtle知识点</h4>
<p>turtle分绝对方向，绝对角度，和海龟方向，海龟角度<br>
turtle.goto(x,y) #让龟龟去窗体内的任何一个位置<br>
turtle.left(angle)  #龟龟自己的方向角度<br>
turtle库默认采用RGB小数值表示颜色turtle.colormode(mode) mode=1.0或255<br>
<strong>from turtle import</strong>*</p>
<h4 id="5天天向上的力量">5.天天向上的力量</h4>
<pre><code>def dayUP(df):
    dayup = 1
    for i in range(365):
        if i % 7 in [0,6]:
            dayup = dayup * (1-0.01)
        else:
            dayup = dayup * (1+df)
    return dayup
dayfactor = 0.01
while dayUP(dayfactor) &lt; 37.78: #每天努力百分之一一年下来会有37.78值
    dayfactor += 0.001
print(&quot;工作日的努力参数是{:.3f}&quot;.format(dayfactor))
</code></pre>
<h4 id="6文本进度条">6.文本进度条</h4>
<pre><code>import time
scale = 50
print(&quot;执行开始&quot;.center(scale//2,'-'))
start = time.perf_counter()
for i in range(scale+1):
    a = '*' * i
    b = '.' * (scale-i)
    c = (i/scale)*100
    dur = time.perf_counter() - start
    print(&quot;\r{:^3.0f}%[{}-&gt;{}]{:.2f}s&quot;.format(c,a,b,dur))
    time.sleep(0.1)
print(&quot;\n&quot;&quot;执行结束&quot;.center(scale//2,'-'))
</code></pre>
<h4 id="7bmi">7.BMI</h4>
<pre><code>height, weight = eval(input('请输入身高(米)和体重(公斤)[逗号隔开]：'))
bmi = weight / pow(height,2)
print(&quot;BMI数值为：{:.2f}&quot;.format(bmi))
who, nat = &quot;&quot;,&quot;&quot;
if bmi &lt; 18.5:
  who, nat = &quot;偏瘦&quot;, &quot;偏瘦&quot;
elif 18.5 &lt;= bmi &lt;24:
  who, nat = &quot;正常&quot;, &quot;正常&quot;
elif 24 &lt;= bmi &lt; 25:
  who, nat = &quot;正常&quot;, &quot;偏胖&quot;
elif 25 &lt;= bmi &lt; 28:
  who, nat = &quot;偏胖&quot;, &quot;偏胖&quot;
elif 28 &lt;= bmi &lt; 30:
  who, nat = &quot;偏胖&quot;, &quot;肥胖&quot;
else:
  who, nat = &quot;肥胖&quot;, &quot;肥胖&quot;
print(&quot;BMI指标为：国际'{}',国内'{}'&quot;.format(who,nat))
</code></pre>
<h4 id="continue-break">continue， break</h4>
<p>for c in &quot;PYTHON&quot; :<br>
if c == &quot;T&quot;:<br>
continue # 跳过当次循环，不跳过当前循环  break # 跳出循环<br>
print(c,end=&quot;&quot;)</p>
<h4 id="8蒙特卡罗法求解派-面积撒点">8.蒙特卡罗法求解派 # 面积撒点</h4>
<pre><code>from random import random
from time import perf_counter
darts = 1000*1000
hits = 0.0
start = perf_counter()
for i in range (1,darts+1):
  x, y = random(), random()
  dist = pow(x**2+y**2, 0.5)
  if dist &lt;=1.0:
    hits+= 1
pi = 4 * (hits/darts)
print(&quot;圆周率值为{}&quot;.format(pi))
print('运行时间为{:.5f}s'.format(perf_counter()-start))
</code></pre>
<h4 id="9七段数码管绘制">9.七段数码管绘制</h4>
<pre><code>import turtle
def drawLine(draw): #绘制单段数码管
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    turtle.right(90)
def drawDigit(digit): #根据数字绘制七段数码管
    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,6,8] else drawLine(False)
    turtle.left(90)
    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)
    turtle.left(180)
    turtle.penup() #为绘制后续数字确定位置
    turtle.fd(20)
def drawDate(date): #获得要输出的数字
    for i in date:
        drawDigit(eval(i))
def main():
    turtle.setup(800,350,200,200)
    turtle.penup()
    turtle.fd(-300)
    turtle.pensize(5)
    drawDate(&quot;20200319&quot;)
    turtle.hideturtle()
    turtle.done()
main()
</code></pre>
<p>=========================================</p>
<pre><code>import turtle,time
def drawGap():
    turtle.penup()
    turtle.fd(5)
def drawLine(draw): #绘制单段数码管
    drawGap()
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    drawGap()
    turtle.right(90)
def drawDigit(digit): #根据数字绘制七段数码管
    drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,6,8] else drawLine(False)
    turtle.left(90)
    drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False)
    drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False)
    drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False)
    turtle.left(180)
    turtle.penup() #为绘制后续数字确定位置
    turtle.fd(20)
def drawDate(date): #获得要输出的数字
    turtle.pencolor('red')
    for i in date:
        if i =='-':
            turtle.write('年',font=('Arial',18,'normal'))
            turtle.pencolor('green')
            turtle.fd(40)
        elif i =='=':
            turtle.write('月', font=('Arial', 18, 'normal'))
        elif i =='+':
            turtle.write('日', font=('Arial', 18, 'normal'))
        else:
            drawDigit(eval(i))
def main():
    turtle.setup(800,350,200,200)
    turtle.penup()
    turtle.fd(-300)
    turtle.pensize(5)
    drawDate(time.strftime(&quot;%y-%m=%d+&quot;,time.gmtime()))
    turtle.hideturtle()
    turtle.done()
main()
</code></pre>
<h4 id="10科赫雪花">10.科赫雪花</h4>
<pre><code>import turtle,time
def koch (size,n):
    if n == 0:
        turtle.fd(size)
    else:
        for angle in [0,60,-120,60]:
            turtle.left(angle)
            koch(size/3,n-1)
def main():
    turtle.setup(600,600)
    turtle.penup()
    turtle.goto(-200,100)
    turtle.pendown()
    turtle.pensize(2)
    level = 2 # 2阶科赫雪花，阶数
    koch(400,level)
    turtle.right(120)
    koch(400, level)
    turtle.right(120)
    koch(400, level)
    turtle.hideturtle()
main()
</code></pre>
<h4 id="11第五周练习题">11.第五周练习题</h4>
<p><strong>a随机密码生成</strong><br>
‪‬‪‬‪‬‪‬以整数17为随机数种子，获取用户输入整数N为长度，产生3个长度为N位的密码，密码的每位是一个数字。每个密码单独一行输出。产生密码采用random.randint()函数。</p>
<pre><code>import random
def genpwd(length): #输入长度3，生成3位数范围
    x = pow(10,length-1) #1
    y = pow(10,length)-1 #999
    return random.randint(x,y) # x &lt;= length &lt;= y
length = eval(input())
random.seed(17)
for i in range(3): #生成3个密码
    print(genpwd(length))
</code></pre>
<p><strong>b连续质数计算</strong><br>
获得用户输入数字N，计算并输出从N开始的5个质数，单行输出，质数间用逗号,分割。需要考虑用户输入的数字N可能是浮点数，应对输入取整数；最后一个输出后不用逗号。</p>
<pre><code>def prime(m):
    （temp=int(math.sqrt(m))
    for i in range(2,temp+1): ）#此方法可减少计算机作不必要晕眩。
    for i in range(2,m): #在2到m范围内运算，看是否有整除数
        if m%i == 0:
            return False
        else:
            return True
n = eval(input())
t = int(n)
if t &lt; n: #只要输入带小数的数，均取整后+1才能作质数判断
    t+=1
count = 5
while count&gt;0:
    if prime(t):
        if count &gt;1 :
            print(t,end=&quot;,&quot;)
        else:
            print(t)
        count-=1
    t+=1
</code></pre>
<p><strong>c任意累积</strong></p>
<pre><code>def cmul(n, *b): #*b为可变参数，是一个组合数据类型，包含1个或多个参数
    s = n
    for item in b:
        s*=item
    return s
print(eval(&quot;cmul({})&quot;.format(input())))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[罗翔法考 | 普法教育]]></title>
        <id>https://pythonangry.github.io/post/G2V6RA7Z4/</id>
        <link href="https://pythonangry.github.io/post/G2V6RA7Z4/">
        </link>
        <updated>2020-03-08T02:39:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>法益作为入罪的基础</strong><br>
<strong>伦理作为出罪的依据</strong></p>
<p><strong><strong>罗老师语录：</strong></strong></p>
<ol>
<li>判罚需要考虑此案对于长远的社会伦理影响。</li>
<li>刑法是双刃剑，一刃对犯罪，一刃对刑法机关.</li>
<li>没有绝对的公平和正义，绝对的对错，这句话本身就是绝对的。公平和正义是绝对的，客观的，是相对不完美的，虽不能至，心向往之。</li>
</ol>
<p><em><strong>解释</strong></em><br>
<strong><strong>类推解释</strong></strong>：创造规则<br>
<strong><strong>扩大解释</strong></strong>：适用规则<br>
：立法和司法均不可类推，否则立法没有存在的必要，创造新规则就行喇</p>
<p>表演——没超越表演的极限——还叫表演：拍裸照<br>
冒充警察抢劫——真警察抢劫——不算冒充：先形式上解释，再实质性解释</p>
<ul>
<li>文理解释：故意杀人，自杀也是杀人</li>
<li>伦理解释：自杀不算故意杀人，本人以外的他人</li>
<li>体系解释：分则要符合总则</li>
<li>当然解释：入罪型解释 <em>严格</em> 入轻以明重 轻的都能入罪，重的更该入了<br>
出罪，举重以明轻，重的都能出罪，轻的更加能出罪，要于行为人有利</li>
<li>同类解释：xxx xxx 或其他，法律的生命是经验而非逻辑</li>
<li>目的解释：符合伦理道德就不是犯罪，解释要朝善的方向去解释</li>
</ul>
<p><em><strong>法律与案例</strong></em></p>
<ul>
<li>
<p>数罪并罚：因侵犯不同法益<br>
例如_买妇女最高判3年_，行为人买妇女后，依据强迫行为如：劳动/强奸/饿死/囚禁，累计叠加相应刑罚。<br>
但法律仍需要考虑不同情况的购买行为，例如有人把妇女买了，立即放了，这也是买，要判高罚吗？<br>
因此，<strong><strong>法律不能只看到严惩，凡事有例外。立法要向善。</strong></strong></p>
</li>
<li>
<p>如果判刑判强奸犯无期，杀死犯也无期，那强奸犯有可能直接杀人灭口，减少被举报的危险。这反倒成为了受害者生命权的危害因素。</p>
</li>
<li>
<p>14-16岁他人与幼女偶尔发生性关系，也是与幼女发生性关系一律判强奸法条的例外。<br>
案例不是单看法条就能判下，要有证据，客观条件等。</p>
</li>
</ul>
<h4 id="对象错误打击错误">对象错误/打击错误</h4>
<p>对象与打击错误重要区分在于犯罪着手时还是着手后<br>
例如张三想打李四，瞄准的是李四，子弹却打到王五，此为打击错误；若张三想打李四，错把王五认错为李四，则是对象错误。</p>
<h4 id="主客观相统一原则慎防主观归罪">主客观相统一原则，慎防主观归罪</h4>
<figure data-type="image" tabindex="1"><img src="https://pythonangry.github.io/post-images/1584954015883.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[摄影]]></title>
        <id>https://pythonangry.github.io/post/Sn37HjLo/</id>
        <link href="https://pythonangry.github.io/post/Sn37HjLo/">
        </link>
        <updated>2020-03-06T13:30:23.000Z</updated>
        <content type="html"><![CDATA[<h4 id="摄影前需要思考的问题">摄影前需要思考的问题</h4>
<ol>
<li>主题是什么</li>
<li>如何突出主题</li>
<li>画面是否简洁</li>
</ol>
<h4 id="光圈与快门镜头与焦距">光圈与快门；镜头与焦距</h4>
<ul>
<li>镜头速度指镜头传送光线的能力</li>
<li>光圈越小（f值越大），景深越大；光圈越大（f值越小），景深越小</li>
<li>20mm广角镜头，50mm标准镜头，400mm远摄镜头</li>
<li>焦距越短，像场越宽，焦距越长，像场越窄</li>
<li>感光度指感光器或胶片对光的敏感度，数值越高，敏感度越高，照片进行正确曝光所需光线量越少<br>
<img src="https://pythonangry.github.io/post-images/1584602175986.jpg" alt="" loading="lazy"></li>
</ul>
<p>0308</p>
<ol>
<li>景深练习 f4（D7最大光圈），快门自动1/60s，25mm<br>
<img src="https://pythonangry.github.io/post-images/1583663618653.JPG" alt="" loading="lazy"></li>
<li>快门练习 1/250s（D7最快门），光圈自动f4，25mm<br>
<img src="https://pythonangry.github.io/post-images/1583663759419.JPG" alt="" loading="lazy"></li>
<li>快门练习 1s，光圈自动f20，ISO自动，70mm<br>
<img src="https://pythonangry.github.io/post-images/1583664422812.JPG" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3月画画儿~]]></title>
        <id>https://pythonangry.github.io/post/XHsIv896B/</id>
        <link href="https://pythonangry.github.io/post/XHsIv896B/">
        </link>
        <updated>2020-03-05T12:43:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id="墨军老师说">墨军老师说</h4>
<ul>
<li>
<p>场面积用短面积的线条笔触比较有生命力哦</p>
</li>
<li>
<p>爱好艺术的朋友画画没有对错哦</p>
</li>
<li>
<p>离你最近的地方是质感最清晰的地方哦</p>
</li>
<li>
<p>一点透视一个面，两点透视一条线，三点透视一个点哦</p>
</li>
<li>
<p>0305今天的主题是一只很可爱的猫哈哈哈😼😺<br>
<img src="https://pythonangry.github.io/post-images/1583412335222.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>0307闹钟响起后很爱做梦，脸上鼻子错位了，可惜画不出来，以后有机会吧<br>
耳朵是 <em>痒</em> 痒的长出了豆芽<br>
<img src="https://pythonangry.github.io/post-images/1583637844267.jpg" alt="" loading="lazy"></p>
</li>
</ul>
<p>-0309<br>
<img src="https://pythonangry.github.io/post-images/1584100504278.jpg" alt="" loading="lazy"></p>
<p>-0312 叠涂的时候又，把底层推开了，应该是油画棒的问题<br>
<img src="https://pythonangry.github.io/post-images/1584956112627.jpg" alt="" loading="lazy"></p>
<p>-0317passpartout 卖了700€ hum...<br>
<img src="https://pythonangry.github.io/post-images/1584448496992.jpg" alt="" loading="lazy"></p>
<p>-0320 大方婉儿面<br>
<img src="https://pythonangry.github.io/post-images/1584956202502.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>